<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<clones>
    <clone nlines="10" distance="10">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2637" startcolumn="16" endline="2646" endcolumn="9">
if (isStatement) {
            // Nashorn extension: anonymous function statements.
            // Do not allow anonymous function statement if extensions
            // are now allowed. But if we are reparsing then anon function
            // statement is possible - because it was used as function
            // expression in surrounding code.
            if (env._no_syntax_extensions &amp;&amp; reparsedFunction == null) {
                expect(IDENT);
            }
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2905" startcolumn="21" endline="2921" endcolumn="21">
if (parseBody) {
                        // Since the lexer can read ahead and lexify some number of tokens in advance and have
                        // them buffered in the TokenStream, we need to produce a lexer state as it was just
                        // before it lexified RBRACE, and not whatever is its current (quite possibly well read
                        // ahead) state.
                        endParserState = new ParserState(Token.descPosition(token), line, linePosition);

                        // NOTE: you might wonder why do we capture/restore parser state before RBRACE instead of
                        // after RBRACE; after all, we could skip the below "expect(RBRACE);" if we captured the
                        // state after it. The reason is that RBRACE is a well-known token that we can expect and
                        // will never involve us getting into a weird lexer state, and as such is a great reparse
                        // point. Typical example of a weird lexer state after RBRACE would be:
                        //     function this_is_skipped() { ... } "use strict";
                        // because lexer is doing weird off-by-one maneuvers around string literal quotes. Instead
                        // of compensating for the possibility of a string literal (or similar) after RBRACE,
                        // we'll rather just restart parsing from this well-known, friendly token instead.
                    }
</source>
    </clone>
    <clone nlines="10" distance="10">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2637" startcolumn="16" endline="2646" endcolumn="9">
if (isStatement) {
            // Nashorn extension: anonymous function statements.
            // Do not allow anonymous function statement if extensions
            // are now allowed. But if we are reparsing then anon function
            // statement is possible - because it was used as function
            // expression in surrounding code.
            if (env._no_syntax_extensions &amp;&amp; reparsedFunction == null) {
                expect(IDENT);
            }
        }
</source>
        <source file="jdk/internal/dynalink/beans/AbstractJavaLinker.java" startline="465" startcolumn="9" endline="474" endcolumn="9">
if(simpleNamedMethod == null) {
            // explicit signature constructor access
            // Java.type("java.awt.Color")["(int,int,int)"]
            // will get Color(int,int,int) constructor of Color class.
            if (name.isEmpty()) {
                return getConstructorMethod(signature);
            }

            return null;
        }
</source>
    </clone>
    <clone nlines="10" distance="2">
        <source file="jdk/nashorn/internal/runtime/AccessorProperty.java" startline="575" startcolumn="9" endline="584" endcolumn="19">
return debug(
            createGetter(
                getLocalType(),
                type,
                primitiveGetter,
                objectGetter,
                programPoint),
            getLocalType(),
            type,
            "get");
</source>
        <source file="jdk/nashorn/internal/runtime/AccessorProperty.java" startline="550" startcolumn="13" endline="559" endcolumn="23">
getter = debug(
                createGetter(
                    getLocalType(),
                    type,
                    primitiveGetter,
                    objectGetter,
                    INVALID_PROGRAM_POINT),
                getLocalType(),
                type,
                "get");
</source>
    </clone>
    <clone nlines="10" distance="10">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1790" startcolumn="9" endline="1799" endcolumn="9">
switch (type) {
        case RBRACE:
        case SEMICOLON:
        case EOL:
            break;

        default:
            expression = expression();
            break;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/NashornLoader.java" startline="79" startcolumn="17" endline="89" endcolumn="17">
switch (pkgName) {
                    case RUNTIME_PKG:
                    case RUNTIME_ARRAYS_PKG:
                    case RUNTIME_LINKER_PKG:
                    case OBJECTS_PKG:
                    case SCRIPTS_PKG:
                        // allow it.
                        break;
                    default:
                        sm.checkPackageAccess(pkgName);
                }
</source>
    </clone>
    <clone nlines="10" distance="3">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1790" startcolumn="9" endline="1799" endcolumn="9">
switch (type) {
        case RBRACE:
        case SEMICOLON:
        case EOL:
            break;

        default:
            expression = expression();
            break;
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1559" startcolumn="9" endline="1569" endcolumn="9">
switch (type) {
        case RBRACE:
        case SEMICOLON:
        case EOL:
        case EOF:
            break;

        default:
            expression = expression();
            break;
        }
</source>
    </clone>
    <clone nlines="10" distance="3">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1790" startcolumn="9" endline="1799" endcolumn="9">
switch (type) {
        case RBRACE:
        case SEMICOLON:
        case EOL:
            break;

        default:
            expression = expression();
            break;
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1595" startcolumn="9" endline="1605" endcolumn="9">
switch (type) {
        case RBRACE:
        case SEMICOLON:
        case EOL:
        case EOF:
            break;

        default:
            expression = expression();
            break;
        }
</source>
    </clone>
    <clone nlines="10" distance="10">
        <source file="jdk/nashorn/internal/parser/JSONParser.java" startline="509" startcolumn="13" endline="518" endcolumn="13">
switch (peek()) {
            case '\t':
            case '\r':
            case '\n':
            case ' ':
                pos++;
                break;
            default:
                return;
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/RegExpScanner.java" startline="574" startcolumn="9" endline="584" endcolumn="9">
switch (ch0) {
        case 'f':
        case 'n':
        case 'r':
        case 't':
        case 'v':
            return commit(1);

        default:
            return false;
        }
</source>
    </clone>
    <clone nlines="10" distance="8">
        <source file="jdk/nashorn/internal/parser/JSONParser.java" startline="509" startcolumn="13" endline="518" endcolumn="13">
switch (peek()) {
            case '\t':
            case '\r':
            case '\n':
            case ' ':
                pos++;
                break;
            default:
                return;
            }
</source>
        <source file="jdk/nashorn/internal/parser/JSONParser.java" startline="508" startcolumn="9" endline="519" endcolumn="9">
while (pos &lt; length) {
            switch (peek()) {
            case '\t':
            case '\r':
            case '\n':
            case ' ':
                pos++;
                break;
            default:
                return;
            }
        }
</source>
    </clone>
    <clone nlines="11" distance="7">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1559" startcolumn="9" endline="1569" endcolumn="9">
switch (type) {
        case RBRACE:
        case SEMICOLON:
        case EOL:
        case EOF:
            break;

        default:
            expression = expression();
            break;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/NashornLoader.java" startline="79" startcolumn="17" endline="89" endcolumn="17">
switch (pkgName) {
                    case RUNTIME_PKG:
                    case RUNTIME_ARRAYS_PKG:
                    case RUNTIME_LINKER_PKG:
                    case OBJECTS_PKG:
                    case SCRIPTS_PKG:
                        // allow it.
                        break;
                    default:
                        sm.checkPackageAccess(pkgName);
                }
</source>
    </clone>
    <clone nlines="11" distance="7">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1595" startcolumn="9" endline="1605" endcolumn="9">
switch (type) {
        case RBRACE:
        case SEMICOLON:
        case EOL:
        case EOF:
            break;

        default:
            expression = expression();
            break;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/NashornLoader.java" startline="79" startcolumn="17" endline="89" endcolumn="17">
switch (pkgName) {
                    case RUNTIME_PKG:
                    case RUNTIME_ARRAYS_PKG:
                    case RUNTIME_LINKER_PKG:
                    case OBJECTS_PKG:
                    case SCRIPTS_PKG:
                        // allow it.
                        break;
                    default:
                        sm.checkPackageAccess(pkgName);
                }
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1559" startcolumn="9" endline="1569" endcolumn="9">
switch (type) {
        case RBRACE:
        case SEMICOLON:
        case EOL:
        case EOF:
            break;

        default:
            expression = expression();
            break;
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="424" startcolumn="13" endline="438" endcolumn="13">
switch (type) {
            case EOF:
                // Can not go any further.
                break loop;
            case EOL:
            case SEMICOLON:
            case RBRACE:
                // Good recovery points.
                next();
                break loop;
            default:
                // So we can recover after EOL.
                nextOrEOL();
                break;
            }
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1595" startcolumn="9" endline="1605" endcolumn="9">
switch (type) {
        case RBRACE:
        case SEMICOLON:
        case EOL:
        case EOF:
            break;

        default:
            expression = expression();
            break;
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="424" startcolumn="13" endline="438" endcolumn="13">
switch (type) {
            case EOF:
                // Can not go any further.
                break loop;
            case EOL:
            case SEMICOLON:
            case RBRACE:
                // Good recovery points.
                next();
                break loop;
            default:
                // So we can recover after EOL.
                nextOrEOL();
                break;
            }
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="587" startcolumn="9" endline="602" endcolumn="55">
return Node.replaceInLexicalContext(
                lc,
                this,
                new FunctionNode(
                        this,
                        lastToken,
                        endParserState,
                        flags,
                        name,
                        returnType,
                        compileUnit,
                        compilationState,
                        body,
                        parameters,
                        thisProperties,
                        rootClass, source, namespace));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="660" startcolumn="9" endline="675" endcolumn="55">
return Node.replaceInLexicalContext(
                lc,
                this,
                new FunctionNode(
                        this,
                        lastToken,
                        endParserState,
                        flags,
                        name,
                        returnType,
                        compileUnit,
                        compilationState,
                        body,
                        parameters,
                        thisProperties,
                        rootClass, source, namespace));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="897" startcolumn="9" endline="912" endcolumn="55">
return Node.replaceInLexicalContext(
                lc,
                this,
                new FunctionNode(
                        this,
                        lastToken,
                        endParserState,
                        flags,
                        name,
                        returnType,
                        compileUnit,
                        compilationState,
                        body,
                        parameters,
                        thisProperties,
                        rootClass, source, namespace));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="958" startcolumn="9" endline="973" endcolumn="55">
return Node.replaceInLexicalContext(
                lc,
                this,
                new FunctionNode(
                        this,
                        lastToken,
                        endParserState,
                        flags,
                        name,
                        returnType,
                        compileUnit,
                        compilationState,
                        body,
                        parameters,
                        thisProperties,
                        rootClass, source, namespace));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="994" startcolumn="9" endline="1011" endcolumn="36">
return Node.replaceInLexicalContext(
                lc,
                this,
                new FunctionNode(
                        this,
                        lastToken,
                        endParserState,
                        flags,
                        name,
                        returnType,
                        compileUnit,
                        compilationState,
                        body,
                        parameters,
                        thisProperties,
                        rootClass,
                        source,
                        namespace));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="1032" startcolumn="9" endline="1049" endcolumn="36">
return Node.replaceInLexicalContext(
                lc,
                this,
                new FunctionNode(
                        this,
                        lastToken,
                        endParserState,
                        flags,
                        name,
                        returnType,
                        compileUnit,
                        compilationState,
                        body,
                        parameters,
                        thisProperties,
                        rootClass,
                        source,
                        namespace));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="1100" startcolumn="9" endline="1115" endcolumn="55">
return Node.replaceInLexicalContext(
                lc,
                this,
                new FunctionNode(
                        this,
                        lastToken,
                        endParserState,
                        flags,
                        name,
                        returnType,
                        compileUnit,
                        compilationState,
                        body,
                        parameters,
                        thisProperties,
                        rootClass, source, namespace));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="1188" startcolumn="9" endline="1204" endcolumn="19">
return Node.replaceInLexicalContext(
            lc,
            this,
            new FunctionNode(
                this,
                lastToken,
                endParserState,
                flags,
                name,
                type,
                compileUnit,
                compilationState,
                body,
                parameters,
                thisProperties,
                rootClass, source, namespace
                ));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="1236" startcolumn="9" endline="1251" endcolumn="55">
return Node.replaceInLexicalContext(
                lc,
                this,
                new FunctionNode(
                        this,
                        lastToken,
                        endParserState,
                        flags,
                        name,
                        returnType,
                        compileUnit,
                        compilationState,
                        body,
                        parameters,
                        thisProperties,
                        rootClass, source, namespace));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="1292" startcolumn="9" endline="1307" endcolumn="55">
return Node.replaceInLexicalContext(
                lc,
                this,
                new FunctionNode(
                        this,
                        lastToken,
                        endParserState,
                        flags,
                        name,
                        returnType,
                        compileUnit,
                        compilationState,
                        body,
                        parameters,
                        thisProperties,
                        rootClass, source, namespace));
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/ir/FunctionNode.java" startline="449" startcolumn="9" endline="461" endcolumn="42">
return new FunctionNode(
            this,
            lastToken,
            endParserState,
            flags,
            name,
            returnType,
            compileUnit,
            compilationState,
            body,
            parameters,
            thisProperties,
            rootClass, source, namespace);
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="481" startcolumn="9" endline="493" endcolumn="23">
final FunctionNode functionNode =
            new FunctionNode(
                source,
                functionLine,
                token,
                Token.descPosition(token),
                startToken,
                namespace,
                ident,
                name,
                parameters,
                kind,
                flags);
</source>
    </clone>
    <clone nlines="15" distance="6">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="424" startcolumn="13" endline="438" endcolumn="13">
switch (type) {
            case EOF:
                // Can not go any further.
                break loop;
            case EOL:
            case SEMICOLON:
            case RBRACE:
                // Good recovery points.
                next();
                break loop;
            default:
                // So we can recover after EOL.
                nextOrEOL();
                break;
            }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="423" startcolumn="9" endline="439" endcolumn="9">
while (true) {
            switch (type) {
            case EOF:
                // Can not go any further.
                break loop;
            case EOL:
            case SEMICOLON:
            case RBRACE:
                // Good recovery points.
                next();
                break loop;
            default:
                // So we can recover after EOL.
                nextOrEOL();
                break;
            }
        }
</source>
    </clone>
    <clone nlines="15" distance="8">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="424" startcolumn="13" endline="438" endcolumn="13">
switch (type) {
            case EOF:
                // Can not go any further.
                break loop;
            case EOL:
            case SEMICOLON:
            case RBRACE:
                // Good recovery points.
                next();
                break loop;
            default:
                // So we can recover after EOL.
                nextOrEOL();
                break;
            }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="422" startcolumn="1" endline="439" endcolumn="9">
loop:
        while (true) {
            switch (type) {
            case EOF:
                // Can not go any further.
                break loop;
            case EOL:
            case SEMICOLON:
            case RBRACE:
                // Good recovery points.
                next();
                break loop;
            default:
                // So we can recover after EOL.
                nextOrEOL();
                break;
            }
        }
</source>
    </clone>
    <clone nlines="14" distance="2">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1003" startcolumn="9" endline="1016" endcolumn="9">
while (type != EOF) {
            switch (type) {
            case EOF:
            case CASE:
            case DEFAULT:
            case RBRACE:
                break loop;
            default:
                break;
            }

            // Get next statement.
            statement();
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="1002" startcolumn="1" endline="1016" endcolumn="9">
loop:
        while (type != EOF) {
            switch (type) {
            case EOF:
            case CASE:
            case DEFAULT:
            case RBRACE:
                break loop;
            default:
                break;
            }

            // Get next statement.
            statement();
        }
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="jdk/nashorn/internal/codegen/LocalVariableTypesCalculator.java" startline="305" startcolumn="17" endline="315" endcolumn="17">
switch (to) {
                case DOUBLE:
                    recordConversion(L2D);
                    return;
                case OBJECT:
                    recordConversion(L2O);
                    return;
                default:
                    illegalConversion(from, to);
                    return;
                }
</source>
        <source file="jdk/nashorn/internal/codegen/LocalVariableTypesCalculator.java" startline="290" startcolumn="17" endline="303" endcolumn="17">
switch (to) {
                case LONG:
                    recordConversion(I2L);
                    return;
                case DOUBLE:
                    recordConversion(I2D);
                    return;
                case OBJECT:
                    recordConversion(I2O);
                    return;
                default:
                    illegalConversion(from, to);
                    return;
                }
</source>
    </clone>
    <clone nlines="13" distance="8">
        <source file="jdk/nashorn/internal/ir/BinaryNode.java" startline="105" startcolumn="9" endline="117" endcolumn="9">
switch (tokenType()) {
        case EQ:
        case EQ_STRICT:
        case NE:
        case NE_STRICT:
        case LE:
        case LT:
        case GE:
        case GT:
            return true;
        default:
            return false;
        }
</source>
        <source file="jdk/nashorn/internal/ir/RuntimeNode.java" startline="310" startcolumn="13" endline="324" endcolumn="13">
switch (request) {
            case EQ:
            case EQ_STRICT:
            case NE:
            case NE_STRICT:
            case LE:
            case LT:
            case GE:
            case GT:
            case IS_UNDEFINED:
            case IS_NOT_UNDEFINED:
                return true;
            default:
                return false;
            }
</source>
    </clone>
    <clone nlines="17" distance="2">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="423" startcolumn="9" endline="439" endcolumn="9">
while (true) {
            switch (type) {
            case EOF:
                // Can not go any further.
                break loop;
            case EOL:
            case SEMICOLON:
            case RBRACE:
                // Good recovery points.
                next();
                break loop;
            default:
                // So we can recover after EOL.
                nextOrEOL();
                break;
            }
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="422" startcolumn="1" endline="439" endcolumn="9">
loop:
        while (true) {
            switch (type) {
            case EOF:
                // Can not go any further.
                break loop;
            case EOL:
            case SEMICOLON:
            case RBRACE:
                // Good recovery points.
                next();
                break loop;
            default:
                // So we can recover after EOL.
                nextOrEOL();
                break;
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="8">
        <source file="jdk/nashorn/internal/codegen/CodeGenerator.java" startline="3627" startcolumn="21" endline="3636" endcolumn="30">
new OptimisticOperation(unaryNode, typeBounds) {
                        @Override
                        void loadStack() {
                            loadMinusOne();
                        }
                        @Override
                        void consumeStack() {
                            doDecInc(getProgramPoint());
                        }
                    }.emit(1);
</source>
        <source file="jdk/nashorn/internal/codegen/CodeGenerator.java" startline="3609" startcolumn="21" endline="3619" endcolumn="88">
new OptimisticOperation(unaryNode, typeBounds) {
                        @Override
                        void loadStack() {
                            loadRhs();
                            loadMinusOne();
                        }
                        @Override
                        void consumeStack() {
                            doDecInc(getProgramPoint());
                        }
                    }.emit(getOptimisticIgnoreCountForSelfModifyingExpression(operand));
</source>
    </clone>
    <clone nlines="10" distance="6">
        <source file="jdk/nashorn/internal/codegen/CodeGenerator.java" startline="3627" startcolumn="21" endline="3636" endcolumn="30">
new OptimisticOperation(unaryNode, typeBounds) {
                        @Override
                        void loadStack() {
                            loadMinusOne();
                        }
                        @Override
                        void consumeStack() {
                            doDecInc(getProgramPoint());
                        }
                    }.emit(1);
</source>
        <source file="jdk/nashorn/internal/codegen/CodeGenerator.java" startline="3626" startcolumn="17" endline="3637" endcolumn="17">
if (isPostfix) {
                    new OptimisticOperation(unaryNode, typeBounds) {
                        @Override
                        void loadStack() {
                            loadMinusOne();
                        }
                        @Override
                        void consumeStack() {
                            doDecInc(getProgramPoint());
                        }
                    }.emit(1); // 1 for non-incremented result on the top of the stack pushed in evaluate()
                }
</source>
    </clone>
    <clone nlines="15" distance="8">
        <source file="jdk/nashorn/internal/ir/RuntimeNode.java" startline="310" startcolumn="13" endline="324" endcolumn="13">
switch (request) {
            case EQ:
            case EQ_STRICT:
            case NE:
            case NE_STRICT:
            case LE:
            case LT:
            case GE:
            case GT:
            case IS_UNDEFINED:
            case IS_NOT_UNDEFINED:
                return true;
            default:
                return false;
            }
</source>
        <source file="jdk/nashorn/internal/ir/BinaryNode.java" startline="294" startcolumn="9" endline="310" endcolumn="9">
switch (tokenType()) {
        case ASSIGN:
        case ASSIGN_ADD:
        case ASSIGN_BIT_AND:
        case ASSIGN_BIT_OR:
        case ASSIGN_BIT_XOR:
        case ASSIGN_DIV:
        case ASSIGN_MOD:
        case ASSIGN_MUL:
        case ASSIGN_SAR:
        case ASSIGN_SHL:
        case ASSIGN_SHR:
        case ASSIGN_SUB:
           return true;
        default:
           return false;
        }
</source>
    </clone>
    <clone nlines="11" distance="8">
        <source file="jdk/nashorn/internal/runtime/WithObject.java" startline="159" startcolumn="21" endline="169" endcolumn="21">
switch (operator) {
                    case "getMethod":
                        link = self.noSuchMethod(desc, request);
                        break;
                    case "getProp":
                    case "getElem":
                        link = self.noSuchProperty(desc, request);
                        break;
                    default:
                        break;
                    }
</source>
        <source file="jdk/nashorn/internal/runtime/WithObject.java" startline="158" startcolumn="17" endline="170" endcolumn="17">
if (find != null) {
                    switch (operator) {
                    case "getMethod":
                        link = self.noSuchMethod(desc, request);
                        break;
                    case "getProp":
                    case "getElem":
                        link = self.noSuchProperty(desc, request);
                        break;
                    default:
                        break;
                    }
                }
</source>
    </clone>
    <clone nlines="10" distance="5">
        <source file="jdk/nashorn/internal/objects/NativeObject.java" startline="784" startcolumn="13" endline="793" endcolumn="13">
if(isWritable) {
                try {
                    setter = getBeanOperation(linker, "dyn:setProp:" + propertyName, setterType, source);
                } catch(final IllegalAccessError e) {
                    // Presumably, this was a caller sensitive method. Ignore it and carry on.
                    setter = Lookup.EMPTY_SETTER;
                }
            } else {
                setter = Lookup.EMPTY_SETTER;
            }
</source>
        <source file="jdk/nashorn/internal/objects/NativeObject.java" startline="772" startcolumn="13" endline="781" endcolumn="13">
if(readablePropertyNames.contains(propertyName)) {
                try {
                    getter = getBeanOperation(linker, "dyn:getProp:" + propertyName, getterType, source);
                } catch(final IllegalAccessError e) {
                    // Presumably, this was a caller sensitive method. Ignore it and carry on.
                    getter = Lookup.EMPTY_GETTER;
                }
            } else {
                getter = Lookup.EMPTY_GETTER;
            }
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="jdk/nashorn/internal/parser/AbstractParser.java" startline="416" startcolumn="9" endline="426" endcolumn="9">
if (isNonStrictModeIdent()) {
            // Fake out identifier.
            identToken = Token.recast(token, IDENT);
            // Get IDENT.
            final String ident = (String)getValue(identToken);

            next();

            // Create IDENT node.
            return createIdentNode(identToken, finish, ident).setIsFutureStrictName();
        }
</source>
        <source file="jdk/nashorn/internal/parser/AbstractParser.java" startline="490" startcolumn="16" endline="501" endcolumn="9">
if (isIdentifierName()) {
            // Fake out identifier.
            final long identToken = Token.recast(token, IDENT);
            // Get IDENT.
            final String ident = (String)getValue(identToken);
            next();
            // Create IDENT node.
            return createIdentNode(identToken, finish, ident);
        } else {
            expect(IDENT);
            return null;
        }
</source>
    </clone>
    <clone nlines="12" distance="8">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Parser.java" startline="71" startcolumn="13" endline="82" endcolumn="13">
if (ignoreEscaped &amp;&amp; inEsc) {
                inEsc = false;
            } else {
                fetch();
                if (c == code) {
                    restore();
                    return true;
                }
                if (c == syntax.metaCharTable.esc) {
                    inEsc = true;
                }
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Parser.java" startline="70" startcolumn="9" endline="83" endcolumn="9">
while (left()) {
            if (ignoreEscaped &amp;&amp; inEsc) {
                inEsc = false;
            } else {
                fetch();
                if (c == code) {
                    restore();
                    return true;
                }
                if (c == syntax.metaCharTable.esc) {
                    inEsc = true;
                }
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="7">
        <source file="jdk/nashorn/internal/objects/NativeJSAdapter.java" startline="604" startcolumn="9" endline="613" endcolumn="9">
if (overrides &amp;&amp; super.hasOwnProperty(name)) {
            try {
                final GuardedInvocation inv = super.findGetMethod(desc, request, operation);
                if (inv != null) {
                    return inv;
                }
            } catch (final Exception e) {
                //ignored
            }
        }
</source>
        <source file="jdk/nashorn/internal/objects/NativeJSAdapter.java" startline="587" startcolumn="9" endline="596" endcolumn="9">
if (overrides &amp;&amp; super.hasOwnProperty(desc.getNameToken(2))) {
            try {
                final GuardedInvocation inv = super.findCallMethodMethod(desc, request);
                if (inv != null) {
                    return inv;
                }
            } catch (final Exception e) {
                //ignored
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="9">
        <source file="jdk/nashorn/internal/objects/NativeJSAdapter.java" startline="604" startcolumn="9" endline="613" endcolumn="9">
if (overrides &amp;&amp; super.hasOwnProperty(name)) {
            try {
                final GuardedInvocation inv = super.findGetMethod(desc, request, operation);
                if (inv != null) {
                    return inv;
                }
            } catch (final Exception e) {
                //ignored
            }
        }
</source>
        <source file="jdk/nashorn/internal/objects/NativeJSAdapter.java" startline="643" startcolumn="9" endline="652" endcolumn="9">
if (overrides &amp;&amp; super.hasOwnProperty(desc.getNameToken(CallSiteDescriptor.NAME_OPERAND))) {
            try {
                final GuardedInvocation inv = super.findSetMethod(desc, request);
                if (inv != null) {
                    return inv;
                }
            } catch (final Exception e) {
                //ignored
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="7">
        <source file="jdk/nashorn/internal/runtime/ScriptObject.java" startline="888" startcolumn="13" endline="897" endcolumn="13">
if (!compareAndSetMap(oldMap, newMap)) {
                oldMap = getMap();
                final Property oldProperty = oldMap.findProperty(newProperty.getKey());

                if (oldProperty != null) {
                    return oldProperty;
                }
            } else {
                return newProperty;
            }
</source>
        <source file="jdk/nashorn/internal/runtime/ScriptObject.java" startline="1033" startcolumn="13" endline="1042" endcolumn="13">
if (!compareAndSetMap(oldMap, newMap)) {
                oldMap = getMap();
                final Property oldPropertyLookup = oldMap.findProperty(oldProperty.getKey());

                if (oldPropertyLookup != null &amp;&amp; oldPropertyLookup.equals(newProperty)) {
                    return oldPropertyLookup;
                }
            } else {
                return newProperty;
            }
</source>
    </clone>
    <clone nlines="17" distance="9">
        <source file="jdk/nashorn/internal/ir/RuntimeNode.java" startline="253" startcolumn="13" endline="269" endcolumn="13">
switch (request) {
            case EQ:
            case EQ_STRICT:
            case NE:
            case NE_STRICT:
                return request;
            case LE:
                return GE;
            case LT:
                return GT;
            case GE:
                return LE;
            case GT:
                return LT;
            default:
                return null;
            }
</source>
        <source file="jdk/nashorn/internal/ir/RuntimeNode.java" startline="280" startcolumn="13" endline="299" endcolumn="13">
switch (request) {
            case EQ:
                return NE;
            case EQ_STRICT:
                return NE_STRICT;
            case NE:
                return EQ;
            case NE_STRICT:
                return EQ_STRICT;
            case LE:
                return GT;
            case LT:
                return GE;
            case GE:
                return LT;
            case GT:
                return LE;
            default:
                return null;
            }
</source>
    </clone>
    <clone nlines="10" distance="10">
        <source file="jdk/nashorn/tools/Shell.java" startline="212" startcolumn="21" endline="221" endcolumn="21">
try (final FileReader fr = new FileReader(firstFile)) {
                        final int firstChar = fr.read();
                        // starts with '#
                        if (firstChar == '#') {
                            options.set("scripting", true);
                            break;
                        }
                    } catch (final IOException e) {
                        // ignore this. File IO errors will be reported later anyway
                    }
</source>
        <source file="jdk/nashorn/tools/Shell.java" startline="211" startcolumn="17" endline="222" endcolumn="17">
if (firstFile.isFile()) {
                    try (final FileReader fr = new FileReader(firstFile)) {
                        final int firstChar = fr.read();
                        // starts with '#
                        if (firstChar == '#') {
                            options.set("scripting", true);
                            break;
                        }
                    } catch (final IOException e) {
                        // ignore this. File IO errors will be reported later anyway
                    }
                }
</source>
    </clone>
    <clone nlines="10" distance="3">
        <source file="jdk/nashorn/internal/objects/NativeJSAdapter.java" startline="587" startcolumn="9" endline="596" endcolumn="9">
if (overrides &amp;&amp; super.hasOwnProperty(desc.getNameToken(2))) {
            try {
                final GuardedInvocation inv = super.findCallMethodMethod(desc, request);
                if (inv != null) {
                    return inv;
                }
            } catch (final Exception e) {
                //ignored
            }
        }
</source>
        <source file="jdk/nashorn/internal/objects/NativeJSAdapter.java" startline="643" startcolumn="9" endline="652" endcolumn="9">
if (overrides &amp;&amp; super.hasOwnProperty(desc.getNameToken(CallSiteDescriptor.NAME_OPERAND))) {
            try {
                final GuardedInvocation inv = super.findSetMethod(desc, request);
                if (inv != null) {
                    return inv;
                }
            } catch (final Exception e) {
                //ignored
            }
        }
</source>
    </clone>
    <clone nlines="13" distance="6">
        <source file="jdk/nashorn/internal/runtime/NumberToString.java" startline="569" startcolumn="13" endline="581" endcolumn="13">
if (low) {
                if (lowDigitDifference == 0L) {
                    // it's a tie!
                    // choose based on which digits we like.
                    if ((digits0[nDigits - 1] &amp; 1) != 0) {
                        roundup();
                    }
                } else if (lowDigitDifference &gt; 0) {
                    roundup();
                }
            } else {
                roundup();
            }
</source>
        <source file="jdk/nashorn/internal/runtime/NumberToString.java" startline="568" startcolumn="9" endline="582" endcolumn="9">
if (high) {
            if (low) {
                if (lowDigitDifference == 0L) {
                    // it's a tie!
                    // choose based on which digits we like.
                    if ((digits0[nDigits - 1] &amp; 1) != 0) {
                        roundup();
                    }
                } else if (lowDigitDifference &gt; 0) {
                    roundup();
                }
            } else {
                roundup();
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="7">
        <source file="jdk/nashorn/internal/ir/UnaryNode.java" startline="231" startcolumn="13" endline="240" endcolumn="13">
if (name == null) {
                sb.append(tokenType.name());
                rhsParen = true;
            } else {
                sb.append(name);

                if (tokenType.ordinal() &gt; BIT_NOT.ordinal()) {
                    sb.append(' ');
                }
            }
</source>
        <source file="jdk/nashorn/internal/ir/UnaryNode.java" startline="230" startcolumn="9" endline="241" endcolumn="9">
if (!isPostfix) {
            if (name == null) {
                sb.append(tokenType.name());
                rhsParen = true;
            } else {
                sb.append(name);

                if (tokenType.ordinal() &gt; BIT_NOT.ordinal()) {
                    sb.append(' ');
                }
            }
        }
</source>
    </clone>
    <clone nlines="16" distance="8">
        <source file="jdk/nashorn/internal/codegen/Condition.java" startline="55" startcolumn="9" endline="70" endcolumn="9">
switch (c) {
        case EQ:
            return IFEQ;
        case NE:
            return IFNE;
        case LE:
            return IFLE;
        case LT:
            return IFLT;
        case GE:
            return IFGE;
        case GT:
            return IFGT;
        default:
            throw new UnsupportedOperationException("toUnary:" + c.toString());
        }
</source>
        <source file="jdk/nashorn/internal/codegen/Condition.java" startline="74" startcolumn="9" endline="89" endcolumn="9">
switch (c) {
        case EQ:
            return isObject ? IF_ACMPEQ : IF_ICMPEQ;
        case NE:
            return isObject ? IF_ACMPNE : IF_ICMPNE;
        case LE:
            return IF_ICMPLE;
        case LT:
            return IF_ICMPLT;
        case GE:
            return IF_ICMPGE;
        case GT:
            return IF_ICMPGT;
        default:
            throw new UnsupportedOperationException("toBinary:" + c.toString());
        }
</source>
    </clone>
    <clone nlines="11" distance="8">
        <source file="jdk/nashorn/internal/runtime/ScriptFunction.java" startline="731" startcolumn="13" endline="741" endcolumn="13">
if (passesArgs) {
                // R(this, args) =&gt; R(this, Object[])
                appliedType = appliedType.changeParameterType(2, Object[].class);
                // drop any extraneous arguments for the apply fail case
                if (isFailedApplyToCall) {
                    appliedType = appliedType.dropParameterTypes(3, paramCount - 1);
                }
            } else {
                // R(this) =&gt; R(this, Object[])
                appliedType = appliedType.insertParameterTypes(2, Object[].class);
            }
</source>
        <source file="jdk/nashorn/internal/runtime/ScriptFunction.java" startline="730" startcolumn="9" endline="742" endcolumn="9">
if (isApply || isFailedApplyToCall) {
            if (passesArgs) {
                // R(this, args) =&gt; R(this, Object[])
                appliedType = appliedType.changeParameterType(2, Object[].class);
                // drop any extraneous arguments for the apply fail case
                if (isFailedApplyToCall) {
                    appliedType = appliedType.dropParameterTypes(3, paramCount - 1);
                }
            } else {
                // R(this) =&gt; R(this, Object[])
                appliedType = appliedType.insertParameterTypes(2, Object[].class);
            }
        }
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="263" startcolumn="16" endline="273" endcolumn="9">
if (syntax.opEscXHex2()) {
            int num = scanUnsignedHexadecimalNumber(2);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) { /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.RAW_BYTE;
            token.setC(num);
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="296" startcolumn="9" endline="308" endcolumn="9">
if (syntax.opEscOctal3()) {
            unfetch();
            final int last = p;
            int num = scanUnsignedOctalNumber(3);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) {  /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.RAW_BYTE;
            token.setC(num);
        }
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="282" startcolumn="9" endline="292" endcolumn="9">
if (syntax.op2EscUHex4()) {
            int num = scanUnsignedHexadecimalNumber(4);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) {  /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.CODE_POINT;
            token.setCode(num);
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="296" startcolumn="9" endline="308" endcolumn="9">
if (syntax.opEscOctal3()) {
            unfetch();
            final int last = p;
            int num = scanUnsignedOctalNumber(3);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) {  /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.RAW_BYTE;
            token.setC(num);
        }
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="460" startcolumn="16" endline="470" endcolumn="9">
if (syntax.opEscXHex2()) {
            int num = scanUnsignedHexadecimalNumber(2);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) { /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.RAW_BYTE;
            token.setC(num);
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="296" startcolumn="9" endline="308" endcolumn="9">
if (syntax.opEscOctal3()) {
            unfetch();
            final int last = p;
            int num = scanUnsignedOctalNumber(3);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) {  /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.RAW_BYTE;
            token.setC(num);
        }
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="479" startcolumn="9" endline="489" endcolumn="9">
if (syntax.op2EscUHex4()) {
            int num = scanUnsignedHexadecimalNumber(4);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) { /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.CODE_POINT;
            token.setCode(num);
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="296" startcolumn="9" endline="308" endcolumn="9">
if (syntax.opEscOctal3()) {
            unfetch();
            final int last = p;
            int num = scanUnsignedOctalNumber(3);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) {  /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.RAW_BYTE;
            token.setC(num);
        }
</source>
    </clone>
    <clone nlines="11" distance="9">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="496" startcolumn="9" endline="506" endcolumn="10">
return new FieldAccess(className, name, desc) {
            @Override
            public MethodEmitter get(final MethodEmitter method) {
                return method.getField(className, name, descriptor);
            }

            @Override
            public void put(final MethodEmitter method) {
                method.putField(className, name, descriptor);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="368" startcolumn="9" endline="378" endcolumn="10">
return new Call(null, className, name, desc) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokespecial(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, className, name, desc, false);
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="9">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="496" startcolumn="9" endline="506" endcolumn="10">
return new FieldAccess(className, name, desc) {
            @Override
            public MethodEmitter get(final MethodEmitter method) {
                return method.getField(className, name, descriptor);
            }

            @Override
            public void put(final MethodEmitter method) {
                method.putField(className, name, descriptor);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="407" startcolumn="9" endline="417" endcolumn="10">
return new Call(null, className, name, desc) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokestatic(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, className, name, desc, false);
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="9">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="534" startcolumn="9" endline="544" endcolumn="10">
return new FieldAccess(className, name, desc) {
            @Override
            public MethodEmitter get(final MethodEmitter method) {
                return method.getStatic(className, name, descriptor);
            }

            @Override
            public void put(final MethodEmitter method) {
                method.putStatic(className, name, descriptor);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="368" startcolumn="9" endline="378" endcolumn="10">
return new Call(null, className, name, desc) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokespecial(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, className, name, desc, false);
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="9">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="534" startcolumn="9" endline="544" endcolumn="10">
return new FieldAccess(className, name, desc) {
            @Override
            public MethodEmitter get(final MethodEmitter method) {
                return method.getStatic(className, name, descriptor);
            }

            @Override
            public void put(final MethodEmitter method) {
                method.putStatic(className, name, descriptor);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="407" startcolumn="9" endline="417" endcolumn="10">
return new Call(null, className, name, desc) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokestatic(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, className, name, desc, false);
            }
        };
</source>
    </clone>
    <clone nlines="10" distance="5">
        <source file="jdk/nashorn/internal/runtime/GlobalFunctions.java" startline="472" startcolumn="17" endline="481" endcolumn="17">
if (k &lt; (length - 2)) {
                    try {
                        ch = (char) Integer.parseInt(str.substring(k + 1, k + 3), 16);
                        sb.append(ch);
                        k += 2;
                        continue;
                    } catch (final NumberFormatException e) {
                        //ignored
                    }
                }
</source>
        <source file="jdk/nashorn/internal/runtime/GlobalFunctions.java" startline="460" startcolumn="20" endline="469" endcolumn="20">
if (str.charAt(k + 1) == 'u') {
                       try {
                           ch = (char) Integer.parseInt(str.substring(k + 2, k + 6), 16);
                           sb.append(ch);
                           k += 5;
                           continue;
                       } catch (final NumberFormatException e) {
                           //ignored
                       }
                   }
</source>
    </clone>
    <clone nlines="13" distance="2">
        <source file="jdk/nashorn/internal/runtime/Context.java" startline="886" startcolumn="9" endline="898" endcolumn="35">
final Global newGlobal = AccessController.doPrivileged(new PrivilegedAction&lt;Global&gt;() {
           @Override
           public Global run() {
               try {
                   return newGlobal();
               } catch (final RuntimeException e) {
                   if (Context.DEBUG) {
                       e.printStackTrace();
                   }
                   throw e;
               }
           }
        }, CREATE_GLOBAL_ACC_CTXT);
</source>
        <source file="jdk/nashorn/api/scripting/NashornScriptEngine.java" startline="343" startcolumn="9" endline="355" endcolumn="35">
final Global newGlobal = AccessController.doPrivileged(new PrivilegedAction&lt;Global&gt;() {
            @Override
            public Global run() {
                try {
                    return nashornContext.newGlobal();
                } catch (final RuntimeException e) {
                    if (Context.DEBUG) {
                        e.printStackTrace();
                    }
                    throw e;
                }
            }
        }, CREATE_GLOBAL_ACC_CTXT);
</source>
    </clone>
    <clone nlines="13" distance="10">
        <source file="jdk/nashorn/internal/runtime/Context.java" startline="886" startcolumn="9" endline="898" endcolumn="35">
final Global newGlobal = AccessController.doPrivileged(new PrivilegedAction&lt;Global&gt;() {
           @Override
           public Global run() {
               try {
                   return newGlobal();
               } catch (final RuntimeException e) {
                   if (Context.DEBUG) {
                       e.printStackTrace();
                   }
                   throw e;
               }
           }
        }, CREATE_GLOBAL_ACC_CTXT);
</source>
        <source file="jdk/nashorn/api/scripting/NashornScriptEngine.java" startline="125" startcolumn="9" endline="137" endcolumn="36">
this.nashornContext = AccessController.doPrivileged(new PrivilegedAction&lt;Context&gt;() {
            @Override
            public Context run() {
                try {
                    return new Context(options, errMgr, appLoader, classFilter);
                } catch (final RuntimeException e) {
                    if (Context.DEBUG) {
                        e.printStackTrace();
                    }
                    throw e;
                }
            }
        }, CREATE_CONTEXT_ACC_CTXT);
</source>
    </clone>
    <clone nlines="14" distance="10">
        <source file="jdk/nashorn/internal/codegen/CodeGenerator.java" startline="1472" startcolumn="17" endline="1485" endcolumn="25">
new OptimisticOperation(callNode, resultBounds) {
                    int argsCount;
                    @Override
                    void loadStack() {
                        loadExpressionAsObject(ident); // foo() makes no sense if foo == 3
                        // ScriptFunction will see CALLSITE_SCOPE and will bind scope accordingly.
                        method.loadUndefined(Type.OBJECT); //the 'this'
                        argsCount = loadArgs(args);
                    }
                    @Override
                    void consumeStack() {
                        dynamicCall(2 + argsCount, flags);
                    }
                }.emit();
</source>
        <source file="jdk/nashorn/internal/codegen/CodeGenerator.java" startline="1678" startcolumn="17" endline="1692" endcolumn="25">
new OptimisticOperation(callNode, resultBounds) {
                    int argsCount;
                    @Override
                    void loadStack() {
                        // Load up function.
                        loadExpressionAsObject(function); //TODO, e.g. booleans can be used as functions
                        method.loadUndefined(Type.OBJECT); // ScriptFunction will figure out the correct this when it sees CALLSITE_SCOPE
                        argsCount = loadArgs(args);
                        }
                        @Override
                        void consumeStack() {
                            final int flags = getCallSiteFlags() | CALLSITE_SCOPE;
                            dynamicCall(2 + argsCount, flags);
                        }
                }.emit();
</source>
    </clone>
    <clone nlines="10" distance="8">
        <source file="jdk/nashorn/api/scripting/NashornScriptEngine.java" startline="382" startcolumn="13" endline="391" endcolumn="13">
try {
                return ScriptObjectMirror.translateUndefined(selfMirror.callMember(name, args));
            } catch (final Exception e) {
                final Throwable cause = e.getCause();
                if (cause instanceof NoSuchMethodException) {
                    throw (NoSuchMethodException)cause;
                }
                throwAsScriptException(e, invokeGlobal);
                throw new AssertionError("should not reach here");
            }
</source>
        <source file="jdk/nashorn/api/scripting/NashornScriptEngine.java" startline="381" startcolumn="9" endline="392" endcolumn="9">
if (selfMirror != null) {
            try {
                return ScriptObjectMirror.translateUndefined(selfMirror.callMember(name, args));
            } catch (final Exception e) {
                final Throwable cause = e.getCause();
                if (cause instanceof NoSuchMethodException) {
                    throw (NoSuchMethodException)cause;
                }
                throwAsScriptException(e, invokeGlobal);
                throw new AssertionError("should not reach here");
            }
        }
</source>
    </clone>
    <clone nlines="14" distance="10">
        <source file="jdk/nashorn/api/scripting/NashornScriptEngine.java" startline="527" startcolumn="9" endline="540" endcolumn="9">
try {
            if (globalChanged) {
                Context.setGlobal(newGlobal);
            }

            return nashornContext.compileScript(source, newGlobal);
        } catch (final Exception e) {
            throwAsScriptException(e, newGlobal);
            throw new AssertionError("should not reach here");
        } finally {
            if (globalChanged) {
                Context.setGlobal(oldGlobal);
            }
        }
</source>
        <source file="jdk/nashorn/api/scripting/NashornScriptEngine.java" startline="485" startcolumn="9" endline="499" endcolumn="9">
try {
            if (globalChanged) {
                Context.setGlobal(newGlobal);
            }

            mgcs = nashornContext.compileScript(source);
            func = mgcs.getFunction(newGlobal);
        } catch (final Exception e) {
            throwAsScriptException(e, newGlobal);
            throw new AssertionError("should not reach here");
        } finally {
            if (globalChanged) {
                Context.setGlobal(oldGlobal);
            }
        }
</source>
    </clone>
    <clone nlines="13" distance="10">
        <source file="jdk/nashorn/api/scripting/NashornScriptEngine.java" startline="343" startcolumn="9" endline="355" endcolumn="35">
final Global newGlobal = AccessController.doPrivileged(new PrivilegedAction&lt;Global&gt;() {
            @Override
            public Global run() {
                try {
                    return nashornContext.newGlobal();
                } catch (final RuntimeException e) {
                    if (Context.DEBUG) {
                        e.printStackTrace();
                    }
                    throw e;
                }
            }
        }, CREATE_GLOBAL_ACC_CTXT);
</source>
        <source file="jdk/nashorn/api/scripting/NashornScriptEngine.java" startline="125" startcolumn="9" endline="137" endcolumn="36">
this.nashornContext = AccessController.doPrivileged(new PrivilegedAction&lt;Context&gt;() {
            @Override
            public Context run() {
                try {
                    return new Context(options, errMgr, appLoader, classFilter);
                } catch (final RuntimeException e) {
                    if (Context.DEBUG) {
                        e.printStackTrace();
                    }
                    throw e;
                }
            }
        }, CREATE_CONTEXT_ACC_CTXT);
</source>
    </clone>
    <clone nlines="11" distance="4">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ScannerSupport.java" startline="81" startcolumn="13" endline="91" endcolumn="13">
if (EncodingHelper.isXDigit(c)) {
                final int onum = num;
                final int val = EncodingHelper.xdigitVal(c);
                num = (num &lt;&lt; 4) + val;
                if (((onum ^ num) &amp; INT_SIGN_BIT) != 0) {
                    return -1;
                }
            } else {
                unfetch();
                break;
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ScannerSupport.java" startline="103" startcolumn="13" endline="113" endcolumn="13">
if (Character.isDigit(c) &amp;&amp; c &lt; '8') {
                final int onum = num;
                final int val = EncodingHelper.odigitVal(c);
                num = (num &lt;&lt; 3) + val;
                if (((onum ^ num) &amp; INT_SIGN_BIT) != 0) {
                    return -1;
                }
            } else {
                unfetch();
                break;
            }
</source>
    </clone>
    <clone nlines="12" distance="6">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ApplyCaseFold.java" startline="47" startcolumn="17" endline="58" endcolumn="17">
if (to &gt;= BitSet.SINGLE_BYTE_SIZE) {
                    if (cc.isNot()) {
                        cc.clearNotFlag();
                    }
                    cc.addCodeRange(env, to, to);
                } else {
                    if (cc.isNot()) {
                        bs.clear(to);
                    } else {
                        bs.set(to);
                    }
                }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ApplyCaseFold.java" startline="46" startcolumn="13" endline="59" endcolumn="13">
if (inCC) {
                if (to &gt;= BitSet.SINGLE_BYTE_SIZE) {
                    if (cc.isNot()) {
                        cc.clearNotFlag();
                    }
                    cc.addCodeRange(env, to, to);
                } else {
                    if (cc.isNot()) {
                        bs.clear(to);
                    } else {
                        bs.set(to);
                    }
                }
            }
</source>
    </clone>
    <clone nlines="11" distance="8">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="368" startcolumn="9" endline="378" endcolumn="10">
return new Call(null, className, name, desc) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokespecial(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, className, name, desc, false);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="447" startcolumn="9" endline="457" endcolumn="10">
return new Call(null, className(clazz), name, methodDescriptor(rtype, ptypes)) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokevirtual(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, name, descriptor, false);
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="8">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="368" startcolumn="9" endline="378" endcolumn="10">
return new Call(null, className, name, desc) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokespecial(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, className, name, desc, false);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="472" startcolumn="9" endline="482" endcolumn="10">
return new Call(null, className(clazz), name, methodDescriptor(rtype, ptypes)) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokeinterface(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, className, name, descriptor, true);
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="8">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="407" startcolumn="9" endline="417" endcolumn="10">
return new Call(null, className, name, desc) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokestatic(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, className, name, desc, false);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="447" startcolumn="9" endline="457" endcolumn="10">
return new Call(null, className(clazz), name, methodDescriptor(rtype, ptypes)) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokevirtual(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, name, descriptor, false);
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="8">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="407" startcolumn="9" endline="417" endcolumn="10">
return new Call(null, className, name, desc) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokestatic(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, className, name, desc, false);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="472" startcolumn="9" endline="482" endcolumn="10">
return new Call(null, className(clazz), name, methodDescriptor(rtype, ptypes)) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokeinterface(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, className, name, descriptor, true);
            }
        };
</source>
    </clone>
    <clone nlines="12" distance="2">
        <source file="jdk/internal/dynalink/support/TypeConverterFactory.java" startline="118" startcolumn="13" endline="129" endcolumn="14">
return new ClassMap&lt;MethodHandle&gt;(getClassLoader(sourceType)) {
                @Override
                protected MethodHandle computeValue(final Class&lt;?&gt; targetType) {
                    try {
                        return createConverter(sourceType, targetType);
                    } catch (final RuntimeException e) {
                        throw e;
                    } catch (final Exception e) {
                        throw new RuntimeException(e);
                    }
                }
            };
</source>
        <source file="jdk/internal/dynalink/support/TypeConverterFactory.java" startline="154" startcolumn="13" endline="165" endcolumn="14">
return new ClassMap&lt;Boolean&gt;(getClassLoader(sourceType)) {
                @Override
                protected Boolean computeValue(final Class&lt;?&gt; targetType) {
                    try {
                        return getTypeConverterNull(sourceType, targetType) != null;
                    } catch (final RuntimeException e) {
                        throw e;
                    } catch (final Exception e) {
                        throw new RuntimeException(e);
                    }
                }
            };
</source>
    </clone>
    <clone nlines="13" distance="9">
        <source file="jdk/nashorn/internal/runtime/ScriptObject.java" startline="886" startcolumn="9" endline="898" endcolumn="9">
while (true) {
            final PropertyMap newMap = oldMap.addProperty(newProperty);
            if (!compareAndSetMap(oldMap, newMap)) {
                oldMap = getMap();
                final Property oldProperty = oldMap.findProperty(newProperty.getKey());

                if (oldProperty != null) {
                    return oldProperty;
                }
            } else {
                return newProperty;
            }
        }
</source>
        <source file="jdk/nashorn/internal/runtime/ScriptObject.java" startline="1030" startcolumn="9" endline="1043" endcolumn="9">
while (true) {
            final PropertyMap newMap = oldMap.replaceProperty(oldProperty, newProperty);

            if (!compareAndSetMap(oldMap, newMap)) {
                oldMap = getMap();
                final Property oldPropertyLookup = oldMap.findProperty(oldProperty.getKey());

                if (oldPropertyLookup != null &amp;&amp; oldPropertyLookup.equals(newProperty)) {
                    return oldPropertyLookup;
                }
            } else {
                return newProperty;
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="8">
        <source file="jdk/nashorn/internal/runtime/DebuggerSupport.java" startline="278" startcolumn="17" endline="287" endcolumn="17">
for (int i = 0; i &lt; descs.length; i++) {
                    if (i != 0) {
                        sb.append(", ");
                    }

                    final String valueAsString = descs[i].valueAsString;
                    sb.append(descs[i].key);
                    sb.append(": ");
                    sb.append(valueAsString);
                }
</source>
        <source file="jdk/nashorn/internal/runtime/DebuggerSupport.java" startline="277" startcolumn="13" endline="288" endcolumn="13">
if (descs != null) {
                for (int i = 0; i &lt; descs.length; i++) {
                    if (i != 0) {
                        sb.append(", ");
                    }

                    final String valueAsString = descs[i].valueAsString;
                    sb.append(descs[i].key);
                    sb.append(": ");
                    sb.append(valueAsString);
                }
            }
</source>
    </clone>
    <clone nlines="17" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ScanEnvironment.java" startline="86" startcolumn="13" endline="102" endcolumn="13">
switch (c) {
            case 'n': return '\n';
            case 't': return '\t';
            case 'r': return '\r';
            case 'f': return '\f';
            case 'a': return '\007';
            case 'b': return '\010';
            case 'e': return '\033';
            case 'v':
                if (syntax.op2EscVVtab())
                 {
                    return 11; // ???
                }
                break;
            default:
                break;
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ScanEnvironment.java" startline="85" startcolumn="9" endline="103" endcolumn="9">
if (syntax.opEscControlChars()) {
            switch (c) {
            case 'n': return '\n';
            case 't': return '\t';
            case 'r': return '\r';
            case 'f': return '\f';
            case 'a': return '\007';
            case 'b': return '\010';
            case 'e': return '\033';
            case 'v':
                if (syntax.op2EscVVtab())
                 {
                    return 11; // ???
                }
                break;
            default:
                break;
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="1">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="500" startcolumn="9" endline="509" endcolumn="9">
if (chars[s] &gt; 0xff) {
            ip += BitSet.BITSET_SIZE;
            if (!isNotInClassMB()) {opFail(); return;}
        } else {
            if (isInBitSet()) {opFail(); return;}
            ip += BitSet.BITSET_SIZE;
            final int tlen = code[ip++];
            ip += tlen;
            s++;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="442" startcolumn="9" endline="451" endcolumn="9">
if (chars[s] &gt; 0xff) {
            ip += BitSet.BITSET_SIZE;
            if (!isInClassMB()) {opFail(); return;}
        } else {
            if (!isInBitSet()) {opFail(); return;}
            ip += BitSet.BITSET_SIZE;
            final int tlen = code[ip++]; // by code range length
            ip += tlen;
            s++;
        }
</source>
    </clone>
    <clone nlines="10" distance="10">
        <source file="jdk/nashorn/internal/runtime/linker/JavaArgumentConverters.java" startline="211" startcolumn="20" endline="220" endcolumn="13">
if (isString(obj)) {
                return JSType.toLong(obj);
            } else if (obj instanceof Boolean) {
                return (Boolean)obj ? 1L : 0L;
            } else if (obj instanceof ScriptObject) {
                obj = JSType.toPrimitive(obj, Number.class);
                continue;
            } else if (obj == UNDEFINED) {
                return null; // null or 0L?
            }
</source>
        <source file="jdk/nashorn/internal/runtime/linker/JavaArgumentConverters.java" startline="150" startcolumn="20" endline="159" endcolumn="13">
if (obj instanceof ConsString) {
                return JSType.toNumber(obj.toString());
            } else if (obj instanceof Boolean) {
                return (Boolean) obj ? 1 : +0.0;
            } else if (obj instanceof ScriptObject) {
                obj = JSType.toPrimitive(obj, Number.class);
                continue;
            } else if (obj == UNDEFINED) {
                return Double.NaN;
            }
</source>
    </clone>
    <clone nlines="10" distance="10">
        <source file="jdk/nashorn/internal/runtime/linker/JavaArgumentConverters.java" startline="211" startcolumn="20" endline="220" endcolumn="13">
if (isString(obj)) {
                return JSType.toLong(obj);
            } else if (obj instanceof Boolean) {
                return (Boolean)obj ? 1L : 0L;
            } else if (obj instanceof ScriptObject) {
                obj = JSType.toPrimitive(obj, Number.class);
                continue;
            } else if (obj == UNDEFINED) {
                return null; // null or 0L?
            }
</source>
        <source file="jdk/nashorn/internal/runtime/linker/JavaArgumentConverters.java" startline="174" startcolumn="20" endline="183" endcolumn="13">
if (obj instanceof ConsString) {
                return JSType.toNumber(obj.toString());
            } else if (obj instanceof Boolean) {
                return (Boolean) obj ? 1 : +0.0;
            } else if (obj instanceof ScriptObject) {
                obj = JSType.toPrimitive(obj, Number.class);
                continue;
            } else if (obj == UNDEFINED) {
                return Double.NaN;
            }
</source>
    </clone>
    <clone nlines="11" distance="9">
        <source file="jdk/nashorn/internal/parser/Lexer.java" startline="1229" startcolumn="9" endline="1239" endcolumn="9">
if (ch0 == '\\' &amp;&amp; ch1 == 'u') {
            skip(2);
            final int ch = hexSequence(4, TokenType.IDENT);

            if (!Character.isJavaIdentifierStart(ch)) {
                error(Lexer.message("illegal.identifier.character"), TokenType.IDENT, start, position);
            }
        } else if (!Character.isJavaIdentifierStart(ch0)) {
            // Not an identifier.
            return 0;
        }
</source>
        <source file="jdk/nashorn/internal/parser/Lexer.java" startline="1243" startcolumn="13" endline="1254" endcolumn="13">
if (ch0 == '\\' &amp;&amp; ch1 == 'u') {
                skip(2);
                final int ch = hexSequence(4, TokenType.IDENT);

                if (!Character.isJavaIdentifierPart(ch)) {
                    error(Lexer.message("illegal.identifier.character"), TokenType.IDENT, start, position);
                }
            } else if (Character.isJavaIdentifierPart(ch0)) {
                skip(1);
            } else {
                break;
            }
</source>
    </clone>
    <clone nlines="11" distance="8">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="1081" startcolumn="17" endline="1091" endcolumn="17">
if (qn.greedy &amp;&amp; qn.targetEmptyInfo != 0) {
                    if (target.getType() == NodeType.QTFR) {
                        final QuantifierNode tqn = (QuantifierNode)target;
                        if (tqn.headExact != null) {
                            qn.headExact = tqn.headExact;
                            tqn.headExact = null;
                        }
                    } else {
                        qn.headExact = getHeadValueNode(qn.target, true);
                    }
                }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="1080" startcolumn="13" endline="1092" endcolumn="13">
if (Config.USE_OP_PUSH_OR_JUMP_EXACT) {
                if (qn.greedy &amp;&amp; qn.targetEmptyInfo != 0) {
                    if (target.getType() == NodeType.QTFR) {
                        final QuantifierNode tqn = (QuantifierNode)target;
                        if (tqn.headExact != null) {
                            qn.headExact = tqn.headExact;
                            tqn.headExact = null;
                        }
                    } else {
                        qn.headExact = getHeadValueNode(qn.target, true);
                    }
                }
            }
</source>
    </clone>
    <clone nlines="17" distance="2">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/SearchAlgorithm.java" startline="72" startcolumn="13" endline="88" endcolumn="13">
while (s &lt; end) {
                if (text[s] == target[targetP]) {
                    int p = s + 1;
                    int t = targetP + 1;
                    while (t &lt; targetEnd) {
                        if (target[t] != text[p++]) {
                            break;
                        }
                        t++;
                    }

                    if (t == targetEnd) {
                        return s;
                    }
                }
                s++;
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/SearchAlgorithm.java" startline="106" startcolumn="13" endline="122" endcolumn="13">
while (s &gt;= textP) {
                if (text[s] == target[targetP]) {
                    int p = s + 1;
                    int t = targetP + 1;
                    while (t &lt; targetEnd) {
                        if (target[t] != text[p++]) {
                            break;
                        }
                        t++;
                    }
                    if (t == targetEnd) {
                        return s;
                    }
                }
                // s = enc.prevCharHead or s = s &lt;= adjustText ? -1 : s - 1;
                s--;
            }
</source>
    </clone>
    <clone nlines="16" distance="6">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="663" startcolumn="9" endline="678" endcolumn="9">
if (s == end) {
            if (Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                if (str == end || !isNewLine(chars, sprev, end)) {
                    if (isNotEol(msaOptions)) {
                        opFail();
                    }
                }
                return;
            }
            if (isNotEol(msaOptions)) {
                opFail();
            }
            return;
        } else if (isNewLine(chars, s, end)) {
            return;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="683" startcolumn="9" endline="698" endcolumn="9">
if (s == end) {
            if (Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                if (str == end || !isNewLine(chars, sprev, end)) {
                    if (isNotEol(msaOptions)) {
                        opFail();
                    }
                }
                return;
            }
            if (isNotEol(msaOptions)) {
                opFail();
            }
            return;
        } else if (isNewLine(chars, s, end) &amp;&amp; s + 1 == end) {
            return;
        }
</source>
    </clone>
    <clone nlines="11" distance="5">
        <source file="jdk/nashorn/internal/objects/NativeArray.java" startline="1453" startcolumn="13" endline="1463" endcolumn="13">
for (long k = len; k &gt; 0; k--) {
                final long from = k - 1;
                final long to = k + items.length - 1;

                if (sobj.has(from)) {
                    final Object fromValue = sobj.get(from);
                    sobj.set(to, fromValue, CALLSITE_STRICT);
                } else {
                    sobj.delete(to, true);
                }
            }
</source>
        <source file="jdk/nashorn/internal/objects/NativeArray.java" startline="1400" startcolumn="13" endline="1410" endcolumn="13">
for (long k = len - deleteCount; k &gt; start; k--) {
                final long from = k + deleteCount - 1;
                final long to   = k + items.length - 1;

                if (sobj.has(from)) {
                    final Object fromValue = sobj.get(from);
                    sobj.set(to, fromValue, CALLSITE_STRICT);
                } else {
                    sobj.delete(to, true);
                }
            }
</source>
    </clone>
    <clone nlines="14" distance="10">
        <source file="jdk/nashorn/internal/codegen/Lower.java" startline="118" startcolumn="21" endline="131" endcolumn="21">
if (!terminated) {
                        newStatements.add(statement);
                        if (statement.isTerminal() || statement instanceof JumpStatement) { //TODO hasGoto? But some Loops are hasGoto too - why?
                            terminated = true;
                        }
                    } else {
                        statement.accept(new NodeVisitor&lt;LexicalContext&gt;(new LexicalContext()) {
                            @Override
                            public boolean enterVarNode(final VarNode varNode) {
                                newStatements.add(varNode.setInit(null));
                                return false;
                            }
                        });
                    }
</source>
        <source file="jdk/nashorn/internal/codegen/Lower.java" startline="117" startcolumn="17" endline="132" endcolumn="17">
for (final Statement statement : statements) {
                    if (!terminated) {
                        newStatements.add(statement);
                        if (statement.isTerminal() || statement instanceof JumpStatement) { //TODO hasGoto? But some Loops are hasGoto too - why?
                            terminated = true;
                        }
                    } else {
                        statement.accept(new NodeVisitor&lt;LexicalContext&gt;(new LexicalContext()) {
                            @Override
                            public boolean enterVarNode(final VarNode varNode) {
                                newStatements.add(varNode.setInit(null));
                                return false;
                            }
                        });
                    }
                }
</source>
    </clone>
    <clone nlines="12" distance="9">
        <source file="jdk/nashorn/internal/parser/Lexer.java" startline="1243" startcolumn="13" endline="1254" endcolumn="13">
if (ch0 == '\\' &amp;&amp; ch1 == 'u') {
                skip(2);
                final int ch = hexSequence(4, TokenType.IDENT);

                if (!Character.isJavaIdentifierPart(ch)) {
                    error(Lexer.message("illegal.identifier.character"), TokenType.IDENT, start, position);
                }
            } else if (Character.isJavaIdentifierPart(ch0)) {
                skip(1);
            } else {
                break;
            }
</source>
        <source file="jdk/nashorn/internal/parser/Lexer.java" startline="1242" startcolumn="9" endline="1255" endcolumn="9">
while (!atEOF()) {
            if (ch0 == '\\' &amp;&amp; ch1 == 'u') {
                skip(2);
                final int ch = hexSequence(4, TokenType.IDENT);

                if (!Character.isJavaIdentifierPart(ch)) {
                    error(Lexer.message("illegal.identifier.character"), TokenType.IDENT, start, position);
                }
            } else if (Character.isJavaIdentifierPart(ch0)) {
                skip(1);
            } else {
                break;
            }
        }
</source>
    </clone>
    <clone nlines="14" distance="4">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ScannerSupport.java" startline="79" startcolumn="9" endline="92" endcolumn="9">
while(left() &amp;&amp; ml-- != 0) {
            fetch();
            if (EncodingHelper.isXDigit(c)) {
                final int onum = num;
                final int val = EncodingHelper.xdigitVal(c);
                num = (num &lt;&lt; 4) + val;
                if (((onum ^ num) &amp; INT_SIGN_BIT) != 0) {
                    return -1;
                }
            } else {
                unfetch();
                break;
            }
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ScannerSupport.java" startline="101" startcolumn="9" endline="114" endcolumn="9">
while(left() &amp;&amp; ml-- != 0) {
            fetch();
            if (Character.isDigit(c) &amp;&amp; c &lt; '8') {
                final int onum = num;
                final int val = EncodingHelper.odigitVal(c);
                num = (num &lt;&lt; 3) + val;
                if (((onum ^ num) &amp; INT_SIGN_BIT) != 0) {
                    return -1;
                }
            } else {
                unfetch();
                break;
            }
        }
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="jdk/nashorn/internal/objects/NativeArray.java" startline="1400" startcolumn="13" endline="1410" endcolumn="13">
for (long k = len - deleteCount; k &gt; start; k--) {
                final long from = k + deleteCount - 1;
                final long to   = k + items.length - 1;

                if (sobj.has(from)) {
                    final Object fromValue = sobj.get(from);
                    sobj.set(to, fromValue, CALLSITE_STRICT);
                } else {
                    sobj.delete(to, true);
                }
            }
</source>
        <source file="jdk/nashorn/internal/objects/NativeArray.java" startline="1399" startcolumn="16" endline="1411" endcolumn="9">
if (items.length &gt; deleteCount) {
            for (long k = len - deleteCount; k &gt; start; k--) {
                final long from = k + deleteCount - 1;
                final long to   = k + items.length - 1;

                if (sobj.has(from)) {
                    final Object fromValue = sobj.get(from);
                    sobj.set(to, fromValue, CALLSITE_STRICT);
                } else {
                    sobj.delete(to, true);
                }
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="10">
        <source file="jdk/nashorn/internal/runtime/ScriptObject.java" startline="672" startcolumn="17" endline="681" endcolumn="17">
if (property == null) {
                    addOwnProperty(key, propFlags,
                                     newDesc.has(GET) ? newDesc.getGetter() : null,
                                     newDesc.has(SET) ? newDesc.getSetter() : null);
                } else {
                    // Modify old property with the new features.
                    modifyOwnProperty(property, propFlags,
                                        newDesc.has(GET) ? newDesc.getGetter() : null,
                                        newDesc.has(SET) ? newDesc.getSetter() : null);
                }
</source>
        <source file="jdk/nashorn/internal/runtime/ScriptObject.java" startline="671" startcolumn="20" endline="682" endcolumn="13">
if (type == PropertyDescriptor.ACCESSOR) {
                if (property == null) {
                    addOwnProperty(key, propFlags,
                                     newDesc.has(GET) ? newDesc.getGetter() : null,
                                     newDesc.has(SET) ? newDesc.getSetter() : null);
                } else {
                    // Modify old property with the new features.
                    modifyOwnProperty(property, propFlags,
                                        newDesc.has(GET) ? newDesc.getGetter() : null,
                                        newDesc.has(SET) ? newDesc.getSetter() : null);
                }
            }
</source>
    </clone>
    <clone nlines="14" distance="7">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ast/CClassNode.java" startline="427" startcolumn="13" endline="441" endcolumn="13">
if (!not) {
                for (int c=0; c&lt;BitSet.SINGLE_BYTE_SIZE; c++) {
                    if (EncodingHelper.isWord(c)) {
                        bs.set(c);
                    }
                }

                addAllMultiByteRange();
            } else {
                for (int c=0; c&lt;BitSet.SINGLE_BYTE_SIZE; c++) {
                    if (!EncodingHelper.isWord(c)) {
                        bs.set(c);
                    }
                }
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ast/CClassNode.java" startline="392" startcolumn="13" endline="405" endcolumn="13">
if (not) {
                for (int c=0; c&lt;BitSet.SINGLE_BYTE_SIZE; c++) {
                    if (!EncodingHelper.isCodeCType(c, ct)) {
                        bs.set(c);
                    }
                }
                addAllMultiByteRange();
            } else {
                for (int c=0; c&lt;BitSet.SINGLE_BYTE_SIZE; c++) {
                    if (EncodingHelper.isCodeCType(c, ct)) {
                        bs.set(c);
                    }
                }
            }
</source>
    </clone>
    <clone nlines="13" distance="2">
        <source file="jdk/internal/dynalink/support/Lookup.java" startline="279" startcolumn="9" endline="291" endcolumn="9">
try {
            return lookup.findStatic(declaringClass, name, type);
        } catch(final IllegalAccessException e) {
            final IllegalAccessError ee = new IllegalAccessError("Failed to access static method " + methodDescription(
                    declaringClass, name, type));
            ee.initCause(e);
            throw ee;
        } catch(final NoSuchMethodException e) {
            final NoSuchMethodError ee = new NoSuchMethodError("Failed to find static method " + methodDescription(
                    declaringClass, name, type));
            ee.initCause(e);
            throw ee;
        }
</source>
        <source file="jdk/internal/dynalink/support/Lookup.java" startline="248" startcolumn="9" endline="260" endcolumn="9">
try {
            return lookup.findSpecial(declaringClass, name, type, declaringClass);
        } catch(final IllegalAccessException e) {
            final IllegalAccessError ee = new IllegalAccessError("Failed to access special method " + methodDescription(
                    declaringClass, name, type));
            ee.initCause(e);
            throw ee;
        } catch(final NoSuchMethodException e) {
            final NoSuchMethodError ee = new NoSuchMethodError("Failed to find special method " + methodDescription(
                    declaringClass, name, type));
            ee.initCause(e);
            throw ee;
        }
</source>
    </clone>
    <clone nlines="13" distance="2">
        <source file="jdk/internal/dynalink/support/Lookup.java" startline="306" startcolumn="9" endline="318" endcolumn="9">
try {
            return lookup.findVirtual(declaringClass, name, type);
        } catch(final IllegalAccessException e) {
            final IllegalAccessError ee = new IllegalAccessError("Failed to access virtual method " + methodDescription(
                    declaringClass, name, type));
            ee.initCause(e);
            throw ee;
        } catch(final NoSuchMethodException e) {
            final NoSuchMethodError ee = new NoSuchMethodError("Failed to find virtual method " + methodDescription(
                    declaringClass, name, type));
            ee.initCause(e);
            throw ee;
        }
</source>
        <source file="jdk/internal/dynalink/support/Lookup.java" startline="248" startcolumn="9" endline="260" endcolumn="9">
try {
            return lookup.findSpecial(declaringClass, name, type, declaringClass);
        } catch(final IllegalAccessException e) {
            final IllegalAccessError ee = new IllegalAccessError("Failed to access special method " + methodDescription(
                    declaringClass, name, type));
            ee.initCause(e);
            throw ee;
        } catch(final NoSuchMethodException e) {
            final NoSuchMethodError ee = new NoSuchMethodError("Failed to find special method " + methodDescription(
                    declaringClass, name, type));
            ee.initCause(e);
            throw ee;
        }
</source>
    </clone>
    <clone nlines="14" distance="8">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ast/CClassNode.java" startline="392" startcolumn="13" endline="405" endcolumn="13">
if (not) {
                for (int c=0; c&lt;BitSet.SINGLE_BYTE_SIZE; c++) {
                    if (!EncodingHelper.isCodeCType(c, ct)) {
                        bs.set(c);
                    }
                }
                addAllMultiByteRange();
            } else {
                for (int c=0; c&lt;BitSet.SINGLE_BYTE_SIZE; c++) {
                    if (EncodingHelper.isCodeCType(c, ct)) {
                        bs.set(c);
                    }
                }
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ast/CClassNode.java" startline="410" startcolumn="13" endline="423" endcolumn="13">
if (not) {
                for (int c=0; c&lt;BitSet.SINGLE_BYTE_SIZE; c++) {
                    if (!EncodingHelper.isCodeCType(c, ct)) {
                        bs.set(c);
                    }
                }
            } else {
                for (int c=0; c&lt;BitSet.SINGLE_BYTE_SIZE; c++) {
                    if (EncodingHelper.isCodeCType(c, ct)) {
                        bs.set(c);
                    }
                }
                addAllMultiByteRange();
            }
</source>
    </clone>
    <clone nlines="18" distance="2">
        <source file="jdk/internal/dynalink/support/TypeUtilities.java" startline="159" startcolumn="16" endline="176" endcolumn="9">
for(final Class&lt;?&gt; clazz: a1) {
            for(final Iterator&lt;Class&lt;?&gt;&gt; maxiter = max.iterator(); maxiter.hasNext();) {
                final Class&lt;?&gt; maxClazz = maxiter.next();
                if(isSubtype(maxClazz, clazz)) {
                    // It can't be maximal, if there's already a more specific
                    // maximal than it.
                    continue outer;
                }
                if(isSubtype(clazz, maxClazz)) {
                    // If it's more specific than a currently maximal element,
                    // that currently maximal is no longer a maximal.
                    maxiter.remove();
                }
            }
            // If we get here, no current maximal is more specific than the
            // current class, so it is considered maximal as well
            max.add(clazz);
        }
</source>
        <source file="jdk/internal/dynalink/support/TypeUtilities.java" startline="159" startcolumn="9" endline="176" endcolumn="9">
outer: for(final Class&lt;?&gt; clazz: a1) {
            for(final Iterator&lt;Class&lt;?&gt;&gt; maxiter = max.iterator(); maxiter.hasNext();) {
                final Class&lt;?&gt; maxClazz = maxiter.next();
                if(isSubtype(maxClazz, clazz)) {
                    // It can't be maximal, if there's already a more specific
                    // maximal than it.
                    continue outer;
                }
                if(isSubtype(clazz, maxClazz)) {
                    // If it's more specific than a currently maximal element,
                    // that currently maximal is no longer a maximal.
                    maxiter.remove();
                }
            }
            // If we get here, no current maximal is more specific than the
            // current class, so it is considered maximal as well
            max.add(clazz);
        }
</source>
    </clone>
    <clone nlines="14" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="799" startcolumn="21" endline="812" endcolumn="21">
if (qn.target.isSimple()) {
                        final Node x = getHeadValueNode(qn.target, false);
                        if (x != null) {
                            final Node y = getHeadValueNode(nextNode, false);
                            if (y != null &amp;&amp; isNotIncluded(x, y)) {
                                final EncloseNode en = new EncloseNode(EncloseType.STOP_BACKTRACK); //onig_node_new_enclose
                                en.setStopBtSimpleRepeat();
                                //en.setTarget(qn.target); // optimize it ??
                                swap(node, en);

                                en.setTarget(node);
                            }
                        }
                    }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="798" startcolumn="17" endline="813" endcolumn="17">
if (qn.lower &lt;= 1) {
                    if (qn.target.isSimple()) {
                        final Node x = getHeadValueNode(qn.target, false);
                        if (x != null) {
                            final Node y = getHeadValueNode(nextNode, false);
                            if (y != null &amp;&amp; isNotIncluded(x, y)) {
                                final EncloseNode en = new EncloseNode(EncloseType.STOP_BACKTRACK); //onig_node_new_enclose
                                en.setStopBtSimpleRepeat();
                                //en.setTarget(qn.target); // optimize it ??
                                swap(node, en);

                                en.setTarget(node);
                            }
                        }
                    }
                }
</source>
    </clone>
    <clone nlines="12" distance="7">
        <source file="jdk/nashorn/internal/codegen/SplitIntoFunctions.java" startline="333" startcolumn="13" endline="344" endcolumn="13">
if (lc.isFunctionBody()) {
                // Prepend declaration-only var statements to the top of the statement list.
                lc.prependStatements(getCurrentFunctionState().varStatements);
            } else if (lc.isSplitBody()) {
                appendSplitReturn(FALLTHROUGH_STATE, NO_LINE_NUMBER);
                if (getCurrentFunctionState().fn.isProgram()) {
                    // If we're splitting the program, make sure every shard ends with "return :return" and
                    // begins with ":return = :return-in;".
                    lc.prependStatement(new ExpressionStatement(NO_LINE_NUMBER, NO_TOKEN, NO_FINISH,
                            new BinaryNode(Token.toDesc(TokenType.ASSIGN, 0, 0), createReturnIdent(), createReturnParamIdent())));
                }
            }
</source>
        <source file="jdk/nashorn/internal/codegen/SplitIntoFunctions.java" startline="332" startcolumn="9" endline="345" endcolumn="9">
if (!artificialBlock) {
            if (lc.isFunctionBody()) {
                // Prepend declaration-only var statements to the top of the statement list.
                lc.prependStatements(getCurrentFunctionState().varStatements);
            } else if (lc.isSplitBody()) {
                appendSplitReturn(FALLTHROUGH_STATE, NO_LINE_NUMBER);
                if (getCurrentFunctionState().fn.isProgram()) {
                    // If we're splitting the program, make sure every shard ends with "return :return" and
                    // begins with ":return = :return-in;".
                    lc.prependStatement(new ExpressionStatement(NO_LINE_NUMBER, NO_TOKEN, NO_FINISH,
                            new BinaryNode(Token.toDesc(TokenType.ASSIGN, 0, 0), createReturnIdent(), createReturnParamIdent())));
                }
            }
        }
</source>
    </clone>
    <clone nlines="11" distance="2">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="573" startcolumn="9" endline="583" endcolumn="10">
return new Call(MH.findStatic(lookup, clazz, name, MH.type(rtype, ptypes)), className(clazz), name, methodDescriptor(rtype, ptypes)) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokestatic(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, className, name, descriptor, false);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="624" startcolumn="9" endline="634" endcolumn="10">
return new Call(MH.findSpecial(lookup, clazz, name, MH.type(rtype, ptypes), clazz), className(clazz), name, methodDescriptor(rtype, ptypes)) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokespecial(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, className, name, descriptor, false);
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="2">
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="598" startcolumn="9" endline="608" endcolumn="10">
return new Call(MH.findVirtual(lookup, clazz, name, MH.type(rtype, ptypes)), className(clazz), name, methodDescriptor(rtype, ptypes)) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokevirtual(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, name, descriptor, false);
            }
        };
</source>
        <source file="jdk/nashorn/internal/codegen/CompilerConstants.java" startline="624" startcolumn="9" endline="634" endcolumn="10">
return new Call(MH.findSpecial(lookup, clazz, name, MH.type(rtype, ptypes), clazz), className(clazz), name, methodDescriptor(rtype, ptypes)) {
            @Override
            MethodEmitter invoke(final MethodEmitter method) {
                return method.invokespecial(className, name, descriptor);
            }

            @Override
            public void invoke(final MethodVisitor mv) {
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, className, name, descriptor, false);
            }
        };
</source>
    </clone>
    <clone nlines="14" distance="2">
        <source file="jdk/nashorn/internal/runtime/Debug.java" startline="110" startcolumn="9" endline="123" endcolumn="9">
for (int i = depth + 1; i &lt; callers.length &amp;&amp; c != 0; i++) {
            final StackTraceElement element = callers[i];
            final String method = element.getMethodName();

            for (final String ignore : ignores) {
                if (method.compareTo(ignore) == 0) {
                    continue loop;
                }
            }

            result += (method + ":" + element.getLineNumber() +
                       "                              ").substring(0, 30);
            c--;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/Debug.java" startline="109" startcolumn="1" endline="123" endcolumn="9">
loop:
        for (int i = depth + 1; i &lt; callers.length &amp;&amp; c != 0; i++) {
            final StackTraceElement element = callers[i];
            final String method = element.getMethodName();

            for (final String ignore : ignores) {
                if (method.compareTo(ignore) == 0) {
                    continue loop;
                }
            }

            result += (method + ":" + element.getLineNumber() +
                       "                              ").substring(0, 30);
            c--;
        }
</source>
    </clone>
    <clone nlines="14" distance="8">
        <source file="jdk/nashorn/internal/objects/NativeArray.java" startline="513" startcolumn="9" endline="526" endcolumn="9">
if (obj instanceof ScriptObject) {
            final InvokeByName joinInvoker = getJOIN();
            final ScriptObject sobj = (ScriptObject)obj;
            try {
                final Object join = joinInvoker.getGetter().invokeExact(sobj);
                if (Bootstrap.isCallable(join)) {
                    return joinInvoker.getInvoker().invokeExact(join, sobj);
                }
            } catch (final RuntimeException | Error e) {
                throw e;
            } catch (final Throwable t) {
                throw new RuntimeException(t);
            }
        }
</source>
        <source file="jdk/nashorn/internal/objects/NativeObject.java" startline="500" startcolumn="9" endline="516" endcolumn="9">
if (obj instanceof ScriptObject) {
            final InvokeByName toStringInvoker = getTO_STRING();
            final ScriptObject sobj = (ScriptObject)obj;
            try {
                final Object toString = toStringInvoker.getGetter().invokeExact(sobj);

                if (Bootstrap.isCallable(toString)) {
                    return toStringInvoker.getInvoker().invokeExact(toString, sobj);
                }
            } catch (final RuntimeException | Error e) {
                throw e;
            } catch (final Throwable t) {
                throw new RuntimeException(t);
            }

            throw typeError("not.a.function", "toString");
        }
</source>
    </clone>
    <clone nlines="12" distance="6">
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="198" startcolumn="16" endline="209" endcolumn="9">
if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType), Map.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't retrieve elements for objects that are neither arrays, nor list, nor maps.
            return nextComponent;
        }
</source>
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="420" startcolumn="16" endline="432" endcolumn="9">
if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(SET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(PUT_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType),
                    Map.class, ValidationType.INSTANCE_OF, linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't set elements for objects that are neither arrays, nor list, nor maps.
            gic = null;
            collectionType = null;
        }
</source>
    </clone>
    <clone nlines="13" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="364" startcolumn="9" endline="376" endcolumn="9">
if (Config.USE_STRING_TEMPLATES) {
            final char[] bs = regex.templates[code[ip++]];
            int ps = code[ip++];

            while (tlen-- &gt; 0) {
                if (bs[ps++] != chars[s++]) {opFail(); return;}
            }

        } else {
            while (tlen-- &gt; 0) {
                if (code[ip++] != chars[s++]) {opFail(); return;}
            }
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="390" startcolumn="9" endline="402" endcolumn="9">
if (Config.USE_STRING_TEMPLATES) {
            final char[] bs = regex.templates[code[ip++]];
            int ps = code[ip++];

            while (tlen-- &gt; 0) {
                if (bs[ps++] != EncodingHelper.toLowerCase(chars[s++])) {opFail(); return;}
            }
        } else {

            while (tlen-- &gt; 0) {
                if (code[ip++] != EncodingHelper.toLowerCase(chars[s++])) {opFail(); return;}
            }
        }
</source>
    </clone>
    <clone nlines="14" distance="10">
        <source file="jdk/nashorn/api/scripting/NashornException.java" startline="182" startcolumn="13" endline="195" endcolumn="13">
if (ECMAErrors.isScriptFrame(st)) {
                final String className = "&lt;" + st.getFileName() + "&gt;";
                String methodName = st.getMethodName();
                if (methodName.equals(CompilerConstants.PROGRAM.symbolName())) {
                    methodName = "&lt;program&gt;";
                }

                if (methodName.contains(CompilerConstants.ANON_FUNCTION_PREFIX.symbolName())) {
                    methodName = "&lt;anonymous&gt;";
                }

                filtered.add(new StackTraceElement(className, methodName,
                        st.getFileName(), st.getLineNumber()));
            }
</source>
        <source file="jdk/nashorn/api/scripting/NashornException.java" startline="181" startcolumn="9" endline="196" endcolumn="9">
for (final StackTraceElement st : frames) {
            if (ECMAErrors.isScriptFrame(st)) {
                final String className = "&lt;" + st.getFileName() + "&gt;";
                String methodName = st.getMethodName();
                if (methodName.equals(CompilerConstants.PROGRAM.symbolName())) {
                    methodName = "&lt;program&gt;";
                }

                if (methodName.contains(CompilerConstants.ANON_FUNCTION_PREFIX.symbolName())) {
                    methodName = "&lt;anonymous&gt;";
                }

                filtered.add(new StackTraceElement(className, methodName,
                        st.getFileName(), st.getLineNumber()));
            }
        }
</source>
    </clone>
    <clone nlines="26" distance="2">
        <source file="jdk/nashorn/internal/runtime/linker/ClassAndLoader.java" startline="162" startcolumn="17" endline="187" endcolumn="9">
for(final ClassAndLoader maxCandidate: getClassLoadersForTypes(types)) {
            final Iterator&lt;ClassAndLoader&gt; it = maximumVisibilityLoaders.iterator();
            while(it.hasNext()) {
                final ClassAndLoader existingMax = it.next();
                final boolean candidateSeesExisting = maxCandidate.canSee(existingMax);
                final boolean exitingSeesCandidate = existingMax.canSee(maxCandidate);
                if(candidateSeesExisting) {
                    if(!exitingSeesCandidate) {
                        // The candidate sees the the existing maximum, so drop the existing one as it's no longer maximal.
                        it.remove();
                    }
                    // NOTE: there's also the anomalous case where both loaders see each other. Not sure what to do
                    // about that one, as two distinct class loaders both seeing each other's classes is weird and
                    // violates the assumption that the relation "sees others' classes" is a partial ordering. We'll
                    // just not do anything, and treat them as incomparable; hopefully some later class loader that
                    // comes along can eliminate both of them, if it can not, we'll end up with ambiguity anyway and
                    // throw an error at the end.
                } else if(exitingSeesCandidate) {
                    // Existing sees the candidate, so drop the candidate.
                    continue outer;
                }
            }
            // If we get here, no existing maximum visibility loader could see the candidate, so the candidate is a new
            // maximum.
            maximumVisibilityLoaders.add(maxCandidate);
        }
</source>
        <source file="jdk/nashorn/internal/runtime/linker/ClassAndLoader.java" startline="162" startcolumn="9" endline="187" endcolumn="9">
outer:  for(final ClassAndLoader maxCandidate: getClassLoadersForTypes(types)) {
            final Iterator&lt;ClassAndLoader&gt; it = maximumVisibilityLoaders.iterator();
            while(it.hasNext()) {
                final ClassAndLoader existingMax = it.next();
                final boolean candidateSeesExisting = maxCandidate.canSee(existingMax);
                final boolean exitingSeesCandidate = existingMax.canSee(maxCandidate);
                if(candidateSeesExisting) {
                    if(!exitingSeesCandidate) {
                        // The candidate sees the the existing maximum, so drop the existing one as it's no longer maximal.
                        it.remove();
                    }
                    // NOTE: there's also the anomalous case where both loaders see each other. Not sure what to do
                    // about that one, as two distinct class loaders both seeing each other's classes is weird and
                    // violates the assumption that the relation "sees others' classes" is a partial ordering. We'll
                    // just not do anything, and treat them as incomparable; hopefully some later class loader that
                    // comes along can eliminate both of them, if it can not, we'll end up with ambiguity anyway and
                    // throw an error at the end.
                } else if(exitingSeesCandidate) {
                    // Existing sees the candidate, so drop the candidate.
                    continue outer;
                }
            }
            // If we get here, no existing maximum visibility loader could see the candidate, so the candidate is a new
            // maximum.
            maximumVisibilityLoaders.add(maxCandidate);
        }
</source>
    </clone>
    <clone nlines="34" distance="8">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2069" startcolumn="14" endline="2102" endcolumn="13">
switch (type) {
            case RBRACKET:
                next();

                break loop;

            case COMMARIGHT:
                next();

                // If no prior expression
                if (elision) {
                    elements.add(null);
                }

                elision = true;

                break;

            default:
                if (!elision) {
                    throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                }
                // Add expression element.
                final Expression expression = assignmentExpression(false);

                if (expression != null) {
                    elements.add(expression);
                } else {
                    expect(RBRACKET);
                }

                elision = false;
                break;
            }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2067" startcolumn="1" endline="2103" endcolumn="9">
loop:
        while (true) {
             switch (type) {
            case RBRACKET:
                next();

                break loop;

            case COMMARIGHT:
                next();

                // If no prior expression
                if (elision) {
                    elements.add(null);
                }

                elision = true;

                break;

            default:
                if (!elision) {
                    throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                }
                // Add expression element.
                final Expression expression = assignmentExpression(false);

                if (expression != null) {
                    elements.add(expression);
                } else {
                    expect(RBRACKET);
                }

                elision = false;
                break;
            }
        }
</source>
    </clone>
    <clone nlines="34" distance="6">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2069" startcolumn="14" endline="2102" endcolumn="13">
switch (type) {
            case RBRACKET:
                next();

                break loop;

            case COMMARIGHT:
                next();

                // If no prior expression
                if (elision) {
                    elements.add(null);
                }

                elision = true;

                break;

            default:
                if (!elision) {
                    throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                }
                // Add expression element.
                final Expression expression = assignmentExpression(false);

                if (expression != null) {
                    elements.add(expression);
                } else {
                    expect(RBRACKET);
                }

                elision = false;
                break;
            }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2068" startcolumn="9" endline="2103" endcolumn="9">
while (true) {
             switch (type) {
            case RBRACKET:
                next();

                break loop;

            case COMMARIGHT:
                next();

                // If no prior expression
                if (elision) {
                    elements.add(null);
                }

                elision = true;

                break;

            default:
                if (!elision) {
                    throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                }
                // Add expression element.
                final Expression expression = assignmentExpression(false);

                if (expression != null) {
                    elements.add(expression);
                } else {
                    expect(RBRACKET);
                }

                elision = false;
                break;
            }
        }
</source>
    </clone>
    <clone nlines="36" distance="2">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2068" startcolumn="9" endline="2103" endcolumn="9">
while (true) {
             switch (type) {
            case RBRACKET:
                next();

                break loop;

            case COMMARIGHT:
                next();

                // If no prior expression
                if (elision) {
                    elements.add(null);
                }

                elision = true;

                break;

            default:
                if (!elision) {
                    throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                }
                // Add expression element.
                final Expression expression = assignmentExpression(false);

                if (expression != null) {
                    elements.add(expression);
                } else {
                    expect(RBRACKET);
                }

                elision = false;
                break;
            }
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2067" startcolumn="1" endline="2103" endcolumn="9">
loop:
        while (true) {
             switch (type) {
            case RBRACKET:
                next();

                break loop;

            case COMMARIGHT:
                next();

                // If no prior expression
                if (elision) {
                    elements.add(null);
                }

                elision = true;

                break;

            default:
                if (!elision) {
                    throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                }
                // Add expression element.
                final Expression expression = assignmentExpression(false);

                if (expression != null) {
                    elements.add(expression);
                } else {
                    expect(RBRACKET);
                }

                elision = false;
                break;
            }
        }
</source>
    </clone>
    <clone nlines="14" distance="6">
        <source file="jdk/nashorn/internal/runtime/linker/JavaArgumentConverters.java" startline="170" startcolumn="20" endline="183" endcolumn="13">
if (obj instanceof Number) {
                return (Number) obj;
            } else if (obj instanceof String) {
                return JSType.toNumber((String) obj);
            } else if (obj instanceof ConsString) {
                return JSType.toNumber(obj.toString());
            } else if (obj instanceof Boolean) {
                return (Boolean) obj ? 1 : +0.0;
            } else if (obj instanceof ScriptObject) {
                obj = JSType.toPrimitive(obj, Number.class);
                continue;
            } else if (obj == UNDEFINED) {
                return Double.NaN;
            }
</source>
        <source file="jdk/nashorn/internal/runtime/linker/JavaArgumentConverters.java" startline="146" startcolumn="20" endline="159" endcolumn="13">
if (obj instanceof Number) {
                return ((Number)obj).doubleValue();
            } else if (obj instanceof String) {
                return JSType.toNumber((String) obj);
            } else if (obj instanceof ConsString) {
                return JSType.toNumber(obj.toString());
            } else if (obj instanceof Boolean) {
                return (Boolean) obj ? 1 : +0.0;
            } else if (obj instanceof ScriptObject) {
                obj = JSType.toPrimitive(obj, Number.class);
                continue;
            } else if (obj == UNDEFINED) {
                return Double.NaN;
            }
</source>
    </clone>
    <clone nlines="13" distance="6">
        <source file="jdk/nashorn/internal/lookup/Lookup.java" startline="206" startcolumn="16" endline="218" endcolumn="9">
if (!retType.isPrimitive()) {
            if (type == int.class) {
                return MH.filterReturnValue(mh, JSType.TO_INT32.methodHandle());
            } else if (type == long.class) {
                return MH.filterReturnValue(mh, JSType.TO_UINT32.methodHandle());
            } else if (type == double.class) {
                return MH.filterReturnValue(mh, JSType.TO_NUMBER.methodHandle());
            } else if (!type.isPrimitive()) {
                return mh;
            }

            assert false : "unsupported Lookup.filterReturnType type " + retType + " -&gt; " + type;
        }
</source>
        <source file="jdk/nashorn/internal/lookup/Lookup.java" startline="160" startcolumn="16" endline="172" endcolumn="9">
if (!from.isPrimitive()) {
            if (to == int.class) {
                return MH.filterArguments(mh, n, JSType.TO_INT32.methodHandle());
            } else if (to == long.class) {
                return MH.filterArguments(mh, n, JSType.TO_UINT32.methodHandle());
            } else if (to == double.class) {
                return MH.filterArguments(mh, n, JSType.TO_NUMBER.methodHandle());
            } else if (!to.isPrimitive()) {
                return mh;
            }

            assert false : "unsupported Lookup.filterReturnType type " + from + " -&gt; " + to;
        }
</source>
    </clone>
    <clone nlines="16" distance="10">
        <source file="jdk/nashorn/internal/runtime/ConsString.java" startline="116" startcolumn="13" endline="131" endcolumn="13">
if (cs instanceof ConsString) {
                final ConsString cons = (ConsString) cs;
                // Count the times a cons-string is traversed as part of other cons-strings being flattened.
                // If it crosses a threshold we flatten the nested cons-string internally.
                if (cons.state == STATE_FLATTENED || (flattenNested &amp;&amp; ++cons.state &gt;= STATE_THRESHOLD)) {
                    cs = cons.flattened(false);
                } else {
                    stack.addFirst(cons.left);
                    cs = cons.right;
                }
            } else {
                final String str = (String) cs;
                pos -= str.length();
                str.getChars(0, str.length(), chars, pos);
                cs = stack.isEmpty() ? null : stack.pollFirst();
            }
</source>
        <source file="jdk/nashorn/internal/runtime/ConsString.java" startline="115" startcolumn="9" endline="132" endcolumn="29">
do {
            if (cs instanceof ConsString) {
                final ConsString cons = (ConsString) cs;
                // Count the times a cons-string is traversed as part of other cons-strings being flattened.
                // If it crosses a threshold we flatten the nested cons-string internally.
                if (cons.state == STATE_FLATTENED || (flattenNested &amp;&amp; ++cons.state &gt;= STATE_THRESHOLD)) {
                    cs = cons.flattened(false);
                } else {
                    stack.addFirst(cons.left);
                    cs = cons.right;
                }
            } else {
                final String str = (String) cs;
                pos -= str.length();
                str.getChars(0, str.length(), chars, pos);
                cs = stack.isEmpty() ? null : stack.pollFirst();
            }
        } while (cs != null);
</source>
    </clone>
    <clone nlines="36" distance="2">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2518" startcolumn="9" endline="2553" endcolumn="9">
while (true) {
            // Capture token.
            final long callToken = token;

            switch (type) {
            case LBRACKET:
                next();

                // Get array index.
                final Expression index = expression();

                expect(RBRACKET);

                // Create indexing node.
                lhs = new IndexNode(callToken, finish, lhs, index);

                break;

            case PERIOD:
                if (lhs == null) {
                    throw error(AbstractParser.message("expected.operand", type.getNameOrType()));
                }

                next();

                final IdentNode property = getIdentifierName();

                // Create property access node.
                lhs = new AccessNode(callToken, finish, lhs, property.getName());

                break;

            default:
                break loop;
            }
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2517" startcolumn="1" endline="2553" endcolumn="9">
loop:
        while (true) {
            // Capture token.
            final long callToken = token;

            switch (type) {
            case LBRACKET:
                next();

                // Get array index.
                final Expression index = expression();

                expect(RBRACKET);

                // Create indexing node.
                lhs = new IndexNode(callToken, finish, lhs, index);

                break;

            case PERIOD:
                if (lhs == null) {
                    throw error(AbstractParser.message("expected.operand", type.getNameOrType()));
                }

                next();

                final IdentNode property = getIdentifierName();

                // Create property access node.
                lhs = new AccessNode(callToken, finish, lhs, property.getName());

                break;

            default:
                break loop;
            }
        }
</source>
    </clone>
    <clone nlines="36" distance="8">
        <source file="jdk/nashorn/internal/runtime/Context.java" startline="832" startcolumn="13" endline="867" endcolumn="13">
if (scope instanceof ScriptObject &amp;&amp; ((ScriptObject)scope).isScope()) {
                final ScriptObject sobj = (ScriptObject)scope;
                // passed object is a script object
                // Global is the only user accessible scope ScriptObject
                assert sobj.isGlobal() : "non-Global scope object!!";
                return evaluateSource(source, sobj, sobj);
            } else if (scope == null || scope == UNDEFINED) {
                // undefined or null scope. Use current global instance.
                final Global global = getGlobal();
                return evaluateSource(source, global, global);
            } else {
                /*
                 * Arbitrary object passed for scope.
                 * Indirect load that is equivalent to:
                 *
                 *    (function(scope, source) {
                 *        with (scope) {
                 *            eval(&lt;script_from_source&gt;);
                 *        }
                 *    })(scope, source);
                 */
                final Global global = getGlobal();
                // Create a new object. This is where all declarations
                // (var, function) from the evaluated code go.
                // make global to be its __proto__ so that global
                // definitions are accessible to the evaluated code.
                final ScriptObject evalScope = newScope(global);

                // finally, make a WithObject around user supplied scope object
                // so that it's properties are accessible as variables.
                final ScriptObject withObj = ScriptRuntime.openWith(evalScope, scope);

                // evaluate given source with 'withObj' as scope
                // but use global object as "this".
                return evaluateSource(source, withObj, global);
            }
</source>
        <source file="jdk/nashorn/internal/runtime/Context.java" startline="831" startcolumn="9" endline="868" endcolumn="9">
if (source != null) {
            if (scope instanceof ScriptObject &amp;&amp; ((ScriptObject)scope).isScope()) {
                final ScriptObject sobj = (ScriptObject)scope;
                // passed object is a script object
                // Global is the only user accessible scope ScriptObject
                assert sobj.isGlobal() : "non-Global scope object!!";
                return evaluateSource(source, sobj, sobj);
            } else if (scope == null || scope == UNDEFINED) {
                // undefined or null scope. Use current global instance.
                final Global global = getGlobal();
                return evaluateSource(source, global, global);
            } else {
                /*
                 * Arbitrary object passed for scope.
                 * Indirect load that is equivalent to:
                 *
                 *    (function(scope, source) {
                 *        with (scope) {
                 *            eval(&lt;script_from_source&gt;);
                 *        }
                 *    })(scope, source);
                 */
                final Global global = getGlobal();
                // Create a new object. This is where all declarations
                // (var, function) from the evaluated code go.
                // make global to be its __proto__ so that global
                // definitions are accessible to the evaluated code.
                final ScriptObject evalScope = newScope(global);

                // finally, make a WithObject around user supplied scope object
                // so that it's properties are accessible as variables.
                final ScriptObject withObj = ScriptRuntime.openWith(evalScope, scope);

                // evaluate given source with 'withObj' as scope
                // but use global object as "this".
                return evaluateSource(source, withObj, global);
            }
        }
</source>
    </clone>
    <clone nlines="17" distance="8">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ast/QuantifierNode.java" startline="278" startcolumn="17" endline="294" endcolumn="17">
if (!isByNumber() &amp;&amp; !qnt.isByNumber() &amp;&amp; env.syntax.warnReduntantNestedRepeat()) {
                    switch(REDUCE_TABLE[targetQNum][nestQNum]) {
                    case ASIS:
                        break;

                    case DEL:
                        env.reg.getWarnings().warn(new String(chars, p, end) +
                                " redundant nested repeat operator");
                        break;

                    default:
                        env.reg.getWarnings().warn(new String(chars, p, end) +
                                " nested repeat operator " + PopularQStr[targetQNum] +
                                " and " + PopularQStr[nestQNum] + " was replaced with '" +
                                ReduceQStr[REDUCE_TABLE[targetQNum][nestQNum].ordinal()] + "'");
                    }
                }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ast/QuantifierNode.java" startline="277" startcolumn="13" endline="295" endcolumn="13">
if (Config.USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR) {
                if (!isByNumber() &amp;&amp; !qnt.isByNumber() &amp;&amp; env.syntax.warnReduntantNestedRepeat()) {
                    switch(REDUCE_TABLE[targetQNum][nestQNum]) {
                    case ASIS:
                        break;

                    case DEL:
                        env.reg.getWarnings().warn(new String(chars, p, end) +
                                " redundant nested repeat operator");
                        break;

                    default:
                        env.reg.getWarnings().warn(new String(chars, p, end) +
                                " nested repeat operator " + PopularQStr[targetQNum] +
                                " and " + PopularQStr[nestQNum] + " was replaced with '" +
                                ReduceQStr[REDUCE_TABLE[targetQNum][nestQNum].ordinal()] + "'");
                    }
                }
            }
</source>
    </clone>
    <clone nlines="13" distance="7">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/StackMachine.java" startline="289" startcolumn="13" endline="301" endcolumn="13">
if (e.type == POS_NOT) {
                break;
            } else if (e.type == MEM_START) {
                repeatStk[memStartStk + e.getMemNum()] = e.getMemStart();
                repeatStk[memEndStk + e.getMemNum()] = e.getMemStart();
            } else if (e.type == REPEAT_INC) {
                //int si = stack[stk + IREPEAT_INC_SI];
                //stack[si + IREPEAT_COUNT]--;
                stack[e.getSi()].decreaseRepeatCount();
            } else if (e.type == MEM_END){
                repeatStk[memStartStk + e.getMemNum()] = e.getMemStart();
                repeatStk[memEndStk + e.getMemNum()] = e.getMemStart();
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/StackMachine.java" startline="268" startcolumn="13" endline="280" endcolumn="13">
if ((e.type &amp; MASK_POP_USED) != 0) {
                return e;
            } else if (e.type == MEM_START) {
                repeatStk[memStartStk + e.getMemNum()] = e.getMemStart();
                repeatStk[memEndStk + e.getMemNum()] = e.getMemEnd();
            } else if (e.type == REPEAT_INC) {
                //int si = stack[stk + IREPEAT_INC_SI];
                //stack[si + IREPEAT_COUNT]--;
                stack[e.getSi()].decreaseRepeatCount();
            } else if (e.type == MEM_END) {
                repeatStk[memStartStk + e.getMemNum()] = e.getMemStart();
                repeatStk[memEndStk + e.getMemNum()] = e.getMemEnd();
            }
</source>
    </clone>
    <clone nlines="13" distance="7">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/StackMachine.java" startline="310" startcolumn="13" endline="322" endcolumn="13">
if (e.type == LOOK_BEHIND_NOT) {
                break;
            } else if (e.type == MEM_START) {
                repeatStk[memStartStk + e.getMemNum()] = e.getMemStart();
                repeatStk[memEndStk + e.getMemNum()] = e.getMemEnd();
            } else if (e.type == REPEAT_INC) {
                //int si = stack[stk + IREPEAT_INC_SI];
                //stack[si + IREPEAT_COUNT]--;
                stack[e.getSi()].decreaseRepeatCount();
            } else if (e.type == MEM_END) {
                repeatStk[memStartStk + e.getMemNum()] = e.getMemStart();
                repeatStk[memEndStk + e.getMemNum()] = e.getMemEnd();
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/StackMachine.java" startline="268" startcolumn="13" endline="280" endcolumn="13">
if ((e.type &amp; MASK_POP_USED) != 0) {
                return e;
            } else if (e.type == MEM_START) {
                repeatStk[memStartStk + e.getMemNum()] = e.getMemStart();
                repeatStk[memEndStk + e.getMemNum()] = e.getMemEnd();
            } else if (e.type == REPEAT_INC) {
                //int si = stack[stk + IREPEAT_INC_SI];
                //stack[si + IREPEAT_COUNT]--;
                stack[e.getSi()].decreaseRepeatCount();
            } else if (e.type == MEM_END) {
                repeatStk[memStartStk + e.getMemNum()] = e.getMemStart();
                repeatStk[memEndStk + e.getMemNum()] = e.getMemEnd();
            }
</source>
    </clone>
    <clone nlines="15" distance="6">
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="195" startcolumn="16" endline="209" endcolumn="9">
if(clazz.isArray()) {
            gic = getClassGuardedInvocationComponent(linkerServices.filterInternalObjects(MethodHandles.arrayElementGetter(clazz)), callSiteType);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType), Map.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't retrieve elements for objects that are neither arrays, nor list, nor maps.
            return nextComponent;
        }
</source>
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="416" startcolumn="16" endline="432" endcolumn="9">
if(clazz.isArray()) {
            gic = getClassGuardedInvocationComponent(linkerServices.filterInternalObjects(
                    MethodHandles.arrayElementSetter(clazz)), callSiteType);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(SET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(PUT_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType),
                    Map.class, ValidationType.INSTANCE_OF, linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't set elements for objects that are neither arrays, nor list, nor maps.
            gic = null;
            collectionType = null;
        }
</source>
    </clone>
    <clone nlines="29" distance="8">
        <source file="jdk/nashorn/internal/runtime/regexp/RegExpScanner.java" startline="748" startcolumn="13" endline="776" endcolumn="13">
try {
                inCharClass = true;
                push(']');
                commit(1);

                if (ch0 == '^') {
                    inNegativeClass = true;
                    commit(1);
                }

                if (classRanges() &amp;&amp; ch0 == ']') {
                    pop(']');
                    commit(1);

                    // Substitute empty character classes [] and [^] that never or always match
                    if (position == startIn + 2) {
                        sb.setLength(sb.length() - 1);
                        sb.append("^\\s\\S]");
                    } else if (position == startIn + 3 &amp;&amp; inNegativeClass) {
                        sb.setLength(sb.length() - 2);
                        sb.append("\\s\\S]");
                    }

                    return true;
                }
            } finally {
                inCharClass = false;  // no nested character classes in JavaScript
                inNegativeClass = false;
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/RegExpScanner.java" startline="747" startcolumn="9" endline="777" endcolumn="9">
if (ch0 == '[') {
            try {
                inCharClass = true;
                push(']');
                commit(1);

                if (ch0 == '^') {
                    inNegativeClass = true;
                    commit(1);
                }

                if (classRanges() &amp;&amp; ch0 == ']') {
                    pop(']');
                    commit(1);

                    // Substitute empty character classes [] and [^] that never or always match
                    if (position == startIn + 2) {
                        sb.setLength(sb.length() - 1);
                        sb.append("^\\s\\S]");
                    } else if (position == startIn + 3 &amp;&amp; inNegativeClass) {
                        sb.setLength(sb.length() - 2);
                        sb.append("\\s\\S]");
                    }

                    return true;
                }
            } finally {
                inCharClass = false;  // no nested character classes in JavaScript
                inNegativeClass = false;
            }
        }
</source>
    </clone>
    <clone nlines="42" distance="2">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2388" startcolumn="9" endline="2429" endcolumn="9">
while (true) {
            // Capture token.
            callLine  = line;
            callToken = token;

            switch (type) {
            case LPAREN:
                // Get NEW or FUNCTION arguments.
                final List&lt;Expression&gt; arguments = optimizeList(argumentList());

                // Create call node.
                lhs = new CallNode(callLine, callToken, finish, lhs, arguments, false);

                break;

            case LBRACKET:
                next();

                // Get array index.
                final Expression rhs = expression();

                expect(RBRACKET);

                // Create indexing node.
                lhs = new IndexNode(callToken, finish, lhs, rhs);

                break;

            case PERIOD:
                next();

                final IdentNode property = getIdentifierName();

                // Create property access node.
                lhs = new AccessNode(callToken, finish, lhs, property.getName());

                break;

            default:
                break loop;
            }
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2387" startcolumn="1" endline="2429" endcolumn="9">
loop:
        while (true) {
            // Capture token.
            callLine  = line;
            callToken = token;

            switch (type) {
            case LPAREN:
                // Get NEW or FUNCTION arguments.
                final List&lt;Expression&gt; arguments = optimizeList(argumentList());

                // Create call node.
                lhs = new CallNode(callLine, callToken, finish, lhs, arguments, false);

                break;

            case LBRACKET:
                next();

                // Get array index.
                final Expression rhs = expression();

                expect(RBRACKET);

                // Create indexing node.
                lhs = new IndexNode(callToken, finish, lhs, rhs);

                break;

            case PERIOD:
                next();

                final IdentNode property = getIdentifierName();

                // Create property access node.
                lhs = new AccessNode(callToken, finish, lhs, property.getName());

                break;

            default:
                break loop;
            }
        }
</source>
    </clone>
    <clone nlines="29" distance="2">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="865" startcolumn="14" endline="893" endcolumn="9">
for (i=0; i&lt;tlen; i++) {
            final int mem = code[ip++];
            if (backrefInvalid(mem)) {
                continue;
            }

            final int pstart = backrefStart(mem);
            final int pend = backrefEnd(mem);

            final int n = pend - pstart;
            if (s + n &gt; range) {opFail(); return;}

            sprev = s;

            value = s;
            if (!stringCmpIC(regex.caseFoldFlag, pstart, this, n, end))
             {
                continue loop; // STRING_CMP_VALUE_IC
            }
            s = value;

            // if (sprev &lt; chars.length)
            while (sprev + 1 &lt; s) {
                sprev++;
            }

            ip += tlen - i  - 1; // * SIZE_MEMNUM (1)
            break;  /* success */
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="865" startcolumn="9" endline="893" endcolumn="9">
loop:for (i=0; i&lt;tlen; i++) {
            final int mem = code[ip++];
            if (backrefInvalid(mem)) {
                continue;
            }

            final int pstart = backrefStart(mem);
            final int pend = backrefEnd(mem);

            final int n = pend - pstart;
            if (s + n &gt; range) {opFail(); return;}

            sprev = s;

            value = s;
            if (!stringCmpIC(regex.caseFoldFlag, pstart, this, n, end))
             {
                continue loop; // STRING_CMP_VALUE_IC
            }
            s = value;

            // if (sprev &lt; chars.length)
            while (sprev + 1 &lt; s) {
                sprev++;
            }

            ip += tlen - i  - 1; // * SIZE_MEMNUM (1)
            break;  /* success */
        }
</source>
    </clone>
    <clone nlines="24" distance="6">
        <source file="jdk/nashorn/internal/codegen/AssignSymbols.java" startline="351" startcolumn="17" endline="374" endcolumn="17">
if (isBlockScope) {
                    // Check redeclaration in same block
                    if (symbol.hasBeenDeclared()) {
                        throwParserException(ECMAErrors.getMessage("syntax.error.redeclare.variable", name), origin);
                    } else {
                        symbol.setHasBeenDeclared();
                        // Set scope flag on top-level block scoped symbols
                        if (function.isProgram() &amp;&amp; function.getBody() == block) {
                            symbol.setIsScope();
                        }
                    }
                } else if ((flags &amp; IS_INTERNAL) != 0) {
                    // Always create a new definition.
                    symbol = null;
                } else {
                    // Found LET or CONST in parent scope of same function - s SyntaxError
                    if (symbol.isBlockScoped() &amp;&amp; isLocal(lc.getCurrentFunction(), symbol)) {
                        throwParserException(ECMAErrors.getMessage("syntax.error.redeclare.variable", name), origin);
                    }
                    // Not defined in this function. Create a new definition.
                    if (!isLocal(function, symbol) || symbol.less(IS_VAR)) {
                        symbol = null;
                    }
                }
</source>
        <source file="jdk/nashorn/internal/codegen/AssignSymbols.java" startline="350" startcolumn="20" endline="375" endcolumn="13">
if (isVar) {
                if (isBlockScope) {
                    // Check redeclaration in same block
                    if (symbol.hasBeenDeclared()) {
                        throwParserException(ECMAErrors.getMessage("syntax.error.redeclare.variable", name), origin);
                    } else {
                        symbol.setHasBeenDeclared();
                        // Set scope flag on top-level block scoped symbols
                        if (function.isProgram() &amp;&amp; function.getBody() == block) {
                            symbol.setIsScope();
                        }
                    }
                } else if ((flags &amp; IS_INTERNAL) != 0) {
                    // Always create a new definition.
                    symbol = null;
                } else {
                    // Found LET or CONST in parent scope of same function - s SyntaxError
                    if (symbol.isBlockScoped() &amp;&amp; isLocal(lc.getCurrentFunction(), symbol)) {
                        throwParserException(ECMAErrors.getMessage("syntax.error.redeclare.variable", name), origin);
                    }
                    // Not defined in this function. Create a new definition.
                    if (!isLocal(function, symbol) || symbol.less(IS_VAR)) {
                        symbol = null;
                    }
                }
            }
</source>
    </clone>
    <clone nlines="39" distance="6">
        <source file="jdk/nashorn/internal/codegen/ObjectClassGenerator.java" startline="585" startcolumn="13" endline="623" endcolumn="13">
if (fti &lt; ti) {
                //asking for a wider type than currently stored. then it's OK to coerce.
                //e.g. stored as int,  ask for long or double
                //e.g. stored as long, ask for double
                assert fti != TYPE_UNDEFINED_INDEX;
                final MethodHandle tgetter = getterForType(forType, primitiveGetter, objectGetter);
                return MH.asType(tgetter, tgetter.type().changeReturnType(type));
            } else if (fti == ti) {
                //Fast path, never throw exception - exact getter, just unpack if needed
                return getterForType(forType, primitiveGetter, objectGetter);
            } else {
                assert fti &gt; ti;
                //if asking for a narrower type than the storage - throw exception
                //unless FTI is object, in that case we have to go through the converters
                //there is no
                if (fti == TYPE_OBJECT_INDEX) {
                    return MH.filterReturnValue(
                            objectGetter,
                            MH.insertArguments(
                                    converters.get(ti),
                                    1,
                                    programPoint));
                }

                //asking for narrower primitive than we have stored, that is an
                //UnwarrantedOptimismException
                return MH.asType(
                        MH.filterArguments(
                            objectGetter,
                            0,
                            MH.insertArguments(
                                    GET_DIFFERENT,
                                    1,
                                    forType,
                                    primitiveGetter,
                                    objectGetter,
                                    programPoint)),
                        objectGetter.type().changeReturnType(type));
            }
</source>
        <source file="jdk/nashorn/internal/codegen/ObjectClassGenerator.java" startline="584" startcolumn="9" endline="624" endcolumn="9">
if (isOptimistic) {
            if (fti &lt; ti) {
                //asking for a wider type than currently stored. then it's OK to coerce.
                //e.g. stored as int,  ask for long or double
                //e.g. stored as long, ask for double
                assert fti != TYPE_UNDEFINED_INDEX;
                final MethodHandle tgetter = getterForType(forType, primitiveGetter, objectGetter);
                return MH.asType(tgetter, tgetter.type().changeReturnType(type));
            } else if (fti == ti) {
                //Fast path, never throw exception - exact getter, just unpack if needed
                return getterForType(forType, primitiveGetter, objectGetter);
            } else {
                assert fti &gt; ti;
                //if asking for a narrower type than the storage - throw exception
                //unless FTI is object, in that case we have to go through the converters
                //there is no
                if (fti == TYPE_OBJECT_INDEX) {
                    return MH.filterReturnValue(
                            objectGetter,
                            MH.insertArguments(
                                    converters.get(ti),
                                    1,
                                    programPoint));
                }

                //asking for narrower primitive than we have stored, that is an
                //UnwarrantedOptimismException
                return MH.asType(
                        MH.filterArguments(
                            objectGetter,
                            0,
                            MH.insertArguments(
                                    GET_DIFFERENT,
                                    1,
                                    forType,
                                    primitiveGetter,
                                    objectGetter,
                                    programPoint)),
                        objectGetter.type().changeReturnType(type));
            }
        }
</source>
    </clone>
    <clone nlines="33" distance="2">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="825" startcolumn="14" endline="857" endcolumn="9">
for (i=0; i&lt;tlen; i++) {
            final int mem = code[ip++];
            if (backrefInvalid(mem)) {
                continue;
            }

            int pstart = backrefStart(mem);
            final int pend = backrefEnd(mem);

            int n = pend - pstart;
            if (s + n &gt; range) {opFail(); return;}

            sprev = s;
            int swork = s;

            while (n-- &gt; 0) {
                if (chars[pstart++] != chars[swork++]) {
                    continue loop;
                }
            }

            s = swork;

            // beyond string check
            if (sprev &lt; range) {
                while (sprev + 1 &lt; s) {
                    sprev++;
                }
            }

            ip += tlen - i  - 1; // * SIZE_MEMNUM (1)
            break; /* success */
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="825" startcolumn="9" endline="857" endcolumn="9">
loop:for (i=0; i&lt;tlen; i++) {
            final int mem = code[ip++];
            if (backrefInvalid(mem)) {
                continue;
            }

            int pstart = backrefStart(mem);
            final int pend = backrefEnd(mem);

            int n = pend - pstart;
            if (s + n &gt; range) {opFail(); return;}

            sprev = s;
            int swork = s;

            while (n-- &gt; 0) {
                if (chars[pstart++] != chars[swork++]) {
                    continue loop;
                }
            }

            s = swork;

            // beyond string check
            if (sprev &lt; range) {
                while (sprev + 1 &lt; s) {
                    sprev++;
                }
            }

            ip += tlen - i  - 1; // * SIZE_MEMNUM (1)
            break; /* success */
        }
</source>
    </clone>
    <clone nlines="50" distance="2">
        <source file="jdk/nashorn/internal/runtime/GlobalFunctions.java" startline="256" startcolumn="9" endline="305" endcolumn="9">
for (end = start; end &lt; length; end++) {
            ch = str.charAt(end);

            switch (ch) {
            case '.':
                // dot allowed only once
                if (exponentOffset != -1 || dotSeen) {
                    break loop;
                }
                dotSeen = true;
                break;

            case 'e':
            case 'E':
                // 'e'/'E' allow only once
                if (exponentOffset != -1) {
                    break loop;
                }
                exponentOffset = end;
                break;

            case '+':
            case '-':
                // Sign of the exponent. But allowed only if the
                // previous char in the string was 'e' or 'E'.
                if (exponentOffset != end - 1) {
                    break loop;
                }
                break;

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                if (exponentOffset != -1) {
                    // seeing digit after 'e' or 'E'
                    exponentOk = true;
                }
                break;

            default: // ignore garbage at the end
                break loop;
            }
        }
</source>
        <source file="jdk/nashorn/internal/runtime/GlobalFunctions.java" startline="255" startcolumn="1" endline="305" endcolumn="9">
loop:
        for (end = start; end &lt; length; end++) {
            ch = str.charAt(end);

            switch (ch) {
            case '.':
                // dot allowed only once
                if (exponentOffset != -1 || dotSeen) {
                    break loop;
                }
                dotSeen = true;
                break;

            case 'e':
            case 'E':
                // 'e'/'E' allow only once
                if (exponentOffset != -1) {
                    break loop;
                }
                exponentOffset = end;
                break;

            case '+':
            case '-':
                // Sign of the exponent. But allowed only if the
                // previous char in the string was 'e' or 'E'.
                if (exponentOffset != end - 1) {
                    break loop;
                }
                break;

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                if (exponentOffset != -1) {
                    // seeing digit after 'e' or 'E'
                    exponentOk = true;
                }
                break;

            default: // ignore garbage at the end
                break loop;
            }
        }
</source>
    </clone>
    <clone nlines="31" distance="8">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ast/CClassNode.java" startline="341" startcolumn="13" endline="371" endcolumn="13">
switch (ct) {
            case CharacterType.D:
            case CharacterType.S:
            case CharacterType.W:
                ct ^= CharacterType.SPECIAL_MASK;

                if (env.syntax == Syntax.JAVASCRIPT &amp;&amp; ct == CharacterType.SPACE) {
                    // \s in JavaScript includes unicode characters.
                    break;
                }

                if (not) {
                    for (int c = 0; c &lt; BitSet.SINGLE_BYTE_SIZE; c++) {
                        // if (!ASCIIEncoding.INSTANCE.isCodeCType(c, ctype)) bs.set(c);
                        if ((AsciiCtypeTable[c] &amp; (1 &lt;&lt; ct)) == 0) {
                            bs.set(c);
                        }
                    }
                    addAllMultiByteRange();
                } else {
                    for (int c = 0; c &lt; BitSet.SINGLE_BYTE_SIZE; c++) {
                        // if (ASCIIEncoding.INSTANCE.isCodeCType(c, ctype)) bs.set(c);
                        if ((AsciiCtypeTable[c] &amp; (1 &lt;&lt; ct)) != 0) {
                            bs.set(c);
                        }
                    }
                }
                return;
            default:
                break;
            }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ast/CClassNode.java" startline="340" startcolumn="9" endline="372" endcolumn="9">
if (Config.NON_UNICODE_SDW) {
            switch (ct) {
            case CharacterType.D:
            case CharacterType.S:
            case CharacterType.W:
                ct ^= CharacterType.SPECIAL_MASK;

                if (env.syntax == Syntax.JAVASCRIPT &amp;&amp; ct == CharacterType.SPACE) {
                    // \s in JavaScript includes unicode characters.
                    break;
                }

                if (not) {
                    for (int c = 0; c &lt; BitSet.SINGLE_BYTE_SIZE; c++) {
                        // if (!ASCIIEncoding.INSTANCE.isCodeCType(c, ctype)) bs.set(c);
                        if ((AsciiCtypeTable[c] &amp; (1 &lt;&lt; ct)) == 0) {
                            bs.set(c);
                        }
                    }
                    addAllMultiByteRange();
                } else {
                    for (int c = 0; c &lt; BitSet.SINGLE_BYTE_SIZE; c++) {
                        // if (ASCIIEncoding.INSTANCE.isCodeCType(c, ctype)) bs.set(c);
                        if ((AsciiCtypeTable[c] &amp; (1 &lt;&lt; ct)) != 0) {
                            bs.set(c);
                        }
                    }
                }
                return;
            default:
                break;
            }
        }
</source>
    </clone>
    <clone nlines="29" distance="8">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="3147" startcolumn="13" endline="3175" endcolumn="13">
switch (type) {
            case INCPREFIX:
            case DECPREFIX:
                final TokenType opType = type;
                final Expression lhs = expression;
                // ++, -- without operand..
                if (lhs == null) {
                    throw error(AbstractParser.message("expected.lvalue", type.getNameOrType()));
                }

                if (!(lhs instanceof AccessNode ||
                   lhs instanceof IndexNode ||
                   lhs instanceof IdentNode)) {
                    next();
                    return referenceError(lhs, null, env._early_lvalue_error);
                }
                if (lhs instanceof IdentNode) {
                    if (!checkIdentLValue((IdentNode)lhs)) {
                        next();
                        return referenceError(lhs, null, false);
                    }
                    verifyStrictIdent((IdentNode)lhs, "operand for " + opType.getName() + " operator");
                }
                expression = incDecExpression(token, type, expression, true);
                next();
                break;
            default:
                break;
            }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="3146" startcolumn="9" endline="3176" endcolumn="9">
if (last != EOL) {
            switch (type) {
            case INCPREFIX:
            case DECPREFIX:
                final TokenType opType = type;
                final Expression lhs = expression;
                // ++, -- without operand..
                if (lhs == null) {
                    throw error(AbstractParser.message("expected.lvalue", type.getNameOrType()));
                }

                if (!(lhs instanceof AccessNode ||
                   lhs instanceof IndexNode ||
                   lhs instanceof IdentNode)) {
                    next();
                    return referenceError(lhs, null, env._early_lvalue_error);
                }
                if (lhs instanceof IdentNode) {
                    if (!checkIdentLValue((IdentNode)lhs)) {
                        next();
                        return referenceError(lhs, null, false);
                    }
                    verifyStrictIdent((IdentNode)lhs, "operand for " + opType.getName() + " operator");
                }
                expression = incDecExpression(token, type, expression, true);
                next();
                break;
            default:
                break;
            }
        }
</source>
    </clone>
    <clone nlines="18" distance="6">
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="192" startcolumn="16" endline="209" endcolumn="9">
if(Map.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_MAP_ELEMENT, linkerServices);
            collectionType = CollectionType.MAP;
        } else if(clazz.isArray()) {
            gic = getClassGuardedInvocationComponent(linkerServices.filterInternalObjects(MethodHandles.arrayElementGetter(clazz)), callSiteType);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType), Map.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't retrieve elements for objects that are neither arrays, nor list, nor maps.
            return nextComponent;
        }
</source>
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="413" startcolumn="16" endline="432" endcolumn="9">
if(Map.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(PUT_MAP_ELEMENT, linkerServices);
            collectionType = CollectionType.MAP;
        } else if(clazz.isArray()) {
            gic = getClassGuardedInvocationComponent(linkerServices.filterInternalObjects(
                    MethodHandles.arrayElementSetter(clazz)), callSiteType);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(SET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(PUT_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType),
                    Map.class, ValidationType.INSTANCE_OF, linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't set elements for objects that are neither arrays, nor list, nor maps.
            gic = null;
            collectionType = null;
        }
</source>
    </clone>
    <clone nlines="31" distance="8">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="922" startcolumn="17" endline="952" endcolumn="17">
if (e.type == MEM_START) {
                    if (memIsInMemp(e.getMemNum(), memNum, memp)) {
                        final int pstart = e.getMemPStr();
                        if (pend != -1) {
                            if (pend - pstart &gt; end - s) {
                                return false; /* or goto next_mem; */
                            }
                            int p = pstart;

                            value = s;
                            if (ignoreCase) {
                                if (!stringCmpIC(caseFoldFlag, pstart, this, pend - pstart, end)) {
                                    return false; /* or goto next_mem; */
                                }
                            } else {
                                while (p &lt; pend) {
                                    if (chars[p++] != chars[value++]) {
                                        return false; /* or goto next_mem; */
                                    }
                                }
                            }
                            s = value;

                            return true;
                        }
                    }
                } else if (e.type == MEM_END) {
                    if (memIsInMemp(e.getMemNum(), memNum, memp)) {
                        pend = e.getMemPStr();
                    }
                }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/ByteCodeMachine.java" startline="921" startcolumn="20" endline="953" endcolumn="13">
if (level == nest) {
                if (e.type == MEM_START) {
                    if (memIsInMemp(e.getMemNum(), memNum, memp)) {
                        final int pstart = e.getMemPStr();
                        if (pend != -1) {
                            if (pend - pstart &gt; end - s) {
                                return false; /* or goto next_mem; */
                            }
                            int p = pstart;

                            value = s;
                            if (ignoreCase) {
                                if (!stringCmpIC(caseFoldFlag, pstart, this, pend - pstart, end)) {
                                    return false; /* or goto next_mem; */
                                }
                            } else {
                                while (p &lt; pend) {
                                    if (chars[p++] != chars[value++]) {
                                        return false; /* or goto next_mem; */
                                    }
                                }
                            }
                            s = value;

                            return true;
                        }
                    }
                } else if (e.type == MEM_END) {
                    if (memIsInMemp(e.getMemNum(), memNum, memp)) {
                        pend = e.getMemPStr();
                    }
                }
            }
</source>
    </clone>
    <clone nlines="20" distance="8">
        <source file="jdk/nashorn/internal/runtime/ScriptRuntime.java" startline="610" startcolumn="13" endline="629" endcolumn="13">
if (obj instanceof ScriptObject) {
                obj = ((ScriptObject)obj).get(property);
                if(Global.isLocationPropertyPlaceholder(obj)) {
                    if(CompilerConstants.__LINE__.name().equals(property)) {
                        obj = Integer.valueOf(0);
                    } else {
                        obj = "";
                    }
                }
            } else if (object instanceof Undefined) {
                obj = ((Undefined)obj).get(property);
            } else if (object == null) {
                throw typeError("cant.get.property", safeToString(property), "null");
            } else if (JSType.isPrimitive(obj)) {
                obj = ((ScriptObject)JSType.toScriptObject(obj)).get(property);
            } else if (obj instanceof JSObject) {
                obj = ((JSObject)obj).getMember(property.toString());
            } else {
                obj = UNDEFINED;
            }
</source>
        <source file="jdk/nashorn/internal/runtime/ScriptRuntime.java" startline="609" startcolumn="9" endline="630" endcolumn="9">
if (property != null) {
            if (obj instanceof ScriptObject) {
                obj = ((ScriptObject)obj).get(property);
                if(Global.isLocationPropertyPlaceholder(obj)) {
                    if(CompilerConstants.__LINE__.name().equals(property)) {
                        obj = Integer.valueOf(0);
                    } else {
                        obj = "";
                    }
                }
            } else if (object instanceof Undefined) {
                obj = ((Undefined)obj).get(property);
            } else if (object == null) {
                throw typeError("cant.get.property", safeToString(property), "null");
            } else if (JSType.isPrimitive(obj)) {
                obj = ((ScriptObject)JSType.toScriptObject(obj)).get(property);
            } else if (obj instanceof JSObject) {
                obj = ((JSObject)obj).getMember(property.toString());
            } else {
                obj = UNDEFINED;
            }
        }
</source>
    </clone>
    <clone nlines="31" distance="2">
        <source file="jdk/nashorn/internal/objects/NativeJSON.java" startline="378" startcolumn="13" endline="408" endcolumn="13">
if (state.gap.isEmpty()) {
                final int size = partial.size();
                index = 0;
                finalStr.append('[');
                for (final Object str : partial) {
                    finalStr.append(str);
                    if (index &lt; size - 1) {
                        finalStr.append(',');
                    }
                    index++;
                }

                finalStr.append(']');
            } else {
                final int size = partial.size();
                index = 0;
                finalStr.append("[\n");
                finalStr.append(state.indent);
                for (final Object str : partial) {
                    finalStr.append(str);
                    if (index &lt; size - 1) {
                        finalStr.append(",\n");
                        finalStr.append(state.indent);
                    }
                    index++;
                }

                finalStr.append('\n');
                finalStr.append(stepback);
                finalStr.append(']');
            }
</source>
        <source file="jdk/nashorn/internal/objects/NativeJSON.java" startline="308" startcolumn="13" endline="342" endcolumn="13">
if (state.gap.isEmpty()) {
                final int size = partial.size();
                int       index = 0;

                finalStr.append('{');

                for (final Object str : partial) {
                    finalStr.append(str);
                    if (index &lt; size - 1) {
                        finalStr.append(',');
                    }
                    index++;
                }

                finalStr.append('}');
            } else {
                final int size  = partial.size();
                int       index = 0;

                finalStr.append("{\n");
                finalStr.append(state.indent);

                for (final Object str : partial) {
                    finalStr.append(str);
                    if (index &lt; size - 1) {
                        finalStr.append(",\n");
                        finalStr.append(state.indent);
                    }
                    index++;
                }

                finalStr.append('\n');
                finalStr.append(stepback);
                finalStr.append('}');
            }
</source>
    </clone>
    <clone nlines="31" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="440" startcolumn="9" endline="470" endcolumn="9">
if (peekIs('{') &amp;&amp; syntax.opEscXBraceHex8()) {
            inc();
            final int num = scanUnsignedHexadecimalNumber(8);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_WIDE_CHAR_VALUE);
            }
            if (left()) {
                if (EncodingHelper.isXDigit(peek())) {
                    throw new ValueException(ERR_TOO_LONG_WIDE_CHAR_VALUE);
                }
            }

            if (p &gt; last + 1 &amp;&amp; left() &amp;&amp; peekIs('}')) {
                inc();
                token.type = TokenType.CODE_POINT;
                token.setCode(num);
            } else {
                /* can't read nothing or invalid format */
                p = last;
            }
        } else if (syntax.opEscXHex2()) {
            int num = scanUnsignedHexadecimalNumber(2);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) { /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.RAW_BYTE;
            token.setC(num);
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="242" startcolumn="9" endline="273" endcolumn="9">
if (peekIs('{') &amp;&amp; syntax.opEscXBraceHex8()) {
            inc();
            final int num = scanUnsignedHexadecimalNumber(8);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_WIDE_CHAR_VALUE);
            }
            if (left()) {
                final int c2 = peek();
                if (EncodingHelper.isXDigit(c2)) {
                    throw new ValueException(ERR_TOO_LONG_WIDE_CHAR_VALUE);
                }
            }

            if (p &gt; last + 1 &amp;&amp; left() &amp;&amp; peekIs('}')) {
                inc();
                token.type = TokenType.CODE_POINT;
                token.setCode(num);
            } else {
                /* can't read nothing or invalid format */
                p = last;
            }
        } else if (syntax.opEscXHex2()) {
            int num = scanUnsignedHexadecimalNumber(2);
            if (num &lt; 0) {
                throw new ValueException(ERR_TOO_BIG_NUMBER);
            }
            if (p == last) { /* can't read nothing. */
                num = 0; /* but, it's not error */
            }
            token.type = TokenType.RAW_BYTE;
            token.setC(num);
        }
</source>
    </clone>
    <clone nlines="35" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Matcher.java" startline="213" startcolumn="21" endline="247" endcolumn="21">
switch (regex.subAnchor) {
                    case AnchorType.BEGIN_LINE:
                        if (p != string) {
                            final int prev = EncodingHelper.prevCharHead(string, p);
                            if (!EncodingHelper.isNewLine(ch, prev, e)) {
                                p = prev;
                                continue retry;
                            }
                        }
                        break;

                    case AnchorType.END_LINE:
                        if (p == e) {
                            if (!Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                                final int prev = EncodingHelper.prevCharHead(adjrange, p);
                                if (prev == -1) {
                                    return false;
                                }
                                if (EncodingHelper.isNewLine(ch, prev, e)) {
                                    p = prev;
                                    continue retry;
                                }
                            }
                        } else if (!EncodingHelper.isNewLine(ch, p, e)) {
                            p = EncodingHelper.prevCharHead(adjrange, p);
                            if (p == -1) {
                                return false;
                            }
                            continue retry;
                        }
                        break;

                    default:
                        break;
                    }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Matcher.java" startline="212" startcolumn="17" endline="248" endcolumn="17">
if (regex.subAnchor != 0) {
                    switch (regex.subAnchor) {
                    case AnchorType.BEGIN_LINE:
                        if (p != string) {
                            final int prev = EncodingHelper.prevCharHead(string, p);
                            if (!EncodingHelper.isNewLine(ch, prev, e)) {
                                p = prev;
                                continue retry;
                            }
                        }
                        break;

                    case AnchorType.END_LINE:
                        if (p == e) {
                            if (!Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                                final int prev = EncodingHelper.prevCharHead(adjrange, p);
                                if (prev == -1) {
                                    return false;
                                }
                                if (EncodingHelper.isNewLine(ch, prev, e)) {
                                    p = prev;
                                    continue retry;
                                }
                            }
                        } else if (!EncodingHelper.isNewLine(ch, p, e)) {
                            p = EncodingHelper.prevCharHead(adjrange, p);
                            if (p == -1) {
                                return false;
                            }
                            continue retry;
                        }
                        break;

                    default:
                        break;
                    } // switch
                }
</source>
    </clone>
    <clone nlines="36" distance="10">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Matcher.java" startline="121" startcolumn="21" endline="156" endcolumn="21">
switch (regex.subAnchor) {
                    case AnchorType.BEGIN_LINE:
                        if (p != string) {
                            final int prev = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                            if (!EncodingHelper.isNewLine(ch, prev, e)) {
                                // goto retry_gate;
                                pprev = p;
                                p++;
                                continue retry;
                            }
                        }
                        break;

                    case AnchorType.END_LINE:
                        if (p == e) {
                            if (!Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                                final int prev = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                                if (prev != -1 &amp;&amp; EncodingHelper.isNewLine(ch, prev, e)) {
                                    // goto retry_gate;
                                    pprev = p;
                                    p++;
                                    continue retry;
                                }
                            }
                        } else if (!EncodingHelper.isNewLine(ch, p, e)) {
                            //if () break;
                            // goto retry_gate;
                            pprev = p;
                            p++;
                            continue retry;
                        }
                        break;

                    default:
                        break;
                    }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Matcher.java" startline="120" startcolumn="17" endline="157" endcolumn="17">
if (regex.subAnchor != 0) {
                    switch (regex.subAnchor) {
                    case AnchorType.BEGIN_LINE:
                        if (p != string) {
                            final int prev = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                            if (!EncodingHelper.isNewLine(ch, prev, e)) {
                                // goto retry_gate;
                                pprev = p;
                                p++;
                                continue retry;
                            }
                        }
                        break;

                    case AnchorType.END_LINE:
                        if (p == e) {
                            if (!Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                                final int prev = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                                if (prev != -1 &amp;&amp; EncodingHelper.isNewLine(ch, prev, e)) {
                                    // goto retry_gate;
                                    pprev = p;
                                    p++;
                                    continue retry;
                                }
                            }
                        } else if (!EncodingHelper.isNewLine(ch, p, e)) {
                            //if () break;
                            // goto retry_gate;
                            pprev = p;
                            p++;
                            continue retry;
                        }
                        break;

                    default:
                        break;
                    } // switch
                }
</source>
    </clone>
    <clone nlines="20" distance="10">
        <source file="jdk/nashorn/internal/lookup/Lookup.java" startline="199" startcolumn="16" endline="218" endcolumn="9">
if (retType == double.class) {
            if (type == int.class) {
                return MH.filterReturnValue(mh, JSType.TO_INT32_D.methodHandle());
            } else if (type == long.class) {
                return MH.filterReturnValue(mh, JSType.TO_UINT32_D.methodHandle());
            }
            //fallthru
        } else if (!retType.isPrimitive()) {
            if (type == int.class) {
                return MH.filterReturnValue(mh, JSType.TO_INT32.methodHandle());
            } else if (type == long.class) {
                return MH.filterReturnValue(mh, JSType.TO_UINT32.methodHandle());
            } else if (type == double.class) {
                return MH.filterReturnValue(mh, JSType.TO_NUMBER.methodHandle());
            } else if (!type.isPrimitive()) {
                return mh;
            }

            assert false : "unsupported Lookup.filterReturnType type " + retType + " -&gt; " + type;
        }
</source>
        <source file="jdk/nashorn/internal/lookup/Lookup.java" startline="153" startcolumn="16" endline="172" endcolumn="9">
if (from == double.class) {
            if (to == int.class) {
                return MH.filterArguments(mh, n, JSType.TO_INT32_D.methodHandle());
            } else if (to == long.class) {
                return MH.filterArguments(mh, n, JSType.TO_UINT32_D.methodHandle());
            }
            //fallthru
        } else if (!from.isPrimitive()) {
            if (to == int.class) {
                return MH.filterArguments(mh, n, JSType.TO_INT32.methodHandle());
            } else if (to == long.class) {
                return MH.filterArguments(mh, n, JSType.TO_UINT32.methodHandle());
            } else if (to == double.class) {
                return MH.filterArguments(mh, n, JSType.TO_NUMBER.methodHandle());
            } else if (!to.isPrimitive()) {
                return mh;
            }

            assert false : "unsupported Lookup.filterReturnType type " + from + " -&gt; " + to;
        }
</source>
    </clone>
    <clone nlines="34" distance="8">
        <source file="jdk/nashorn/internal/codegen/AssignSymbols.java" startline="342" startcolumn="13" endline="375" endcolumn="13">
if (isParam) {
                if (!isLocal(function, symbol)) {
                    // Not defined in this function. Create a new definition.
                    symbol = null;
                } else if (symbol.isParam()) {
                    // Duplicate parameter. Null return will force an error.
                    throw new AssertionError("duplicate parameter");
                }
            } else if (isVar) {
                if (isBlockScope) {
                    // Check redeclaration in same block
                    if (symbol.hasBeenDeclared()) {
                        throwParserException(ECMAErrors.getMessage("syntax.error.redeclare.variable", name), origin);
                    } else {
                        symbol.setHasBeenDeclared();
                        // Set scope flag on top-level block scoped symbols
                        if (function.isProgram() &amp;&amp; function.getBody() == block) {
                            symbol.setIsScope();
                        }
                    }
                } else if ((flags &amp; IS_INTERNAL) != 0) {
                    // Always create a new definition.
                    symbol = null;
                } else {
                    // Found LET or CONST in parent scope of same function - s SyntaxError
                    if (symbol.isBlockScoped() &amp;&amp; isLocal(lc.getCurrentFunction(), symbol)) {
                        throwParserException(ECMAErrors.getMessage("syntax.error.redeclare.variable", name), origin);
                    }
                    // Not defined in this function. Create a new definition.
                    if (!isLocal(function, symbol) || symbol.less(IS_VAR)) {
                        symbol = null;
                    }
                }
            }
</source>
        <source file="jdk/nashorn/internal/codegen/AssignSymbols.java" startline="340" startcolumn="9" endline="376" endcolumn="9">
if (symbol != null) {
            // Symbol was already defined. Check if it needs to be redefined.
            if (isParam) {
                if (!isLocal(function, symbol)) {
                    // Not defined in this function. Create a new definition.
                    symbol = null;
                } else if (symbol.isParam()) {
                    // Duplicate parameter. Null return will force an error.
                    throw new AssertionError("duplicate parameter");
                }
            } else if (isVar) {
                if (isBlockScope) {
                    // Check redeclaration in same block
                    if (symbol.hasBeenDeclared()) {
                        throwParserException(ECMAErrors.getMessage("syntax.error.redeclare.variable", name), origin);
                    } else {
                        symbol.setHasBeenDeclared();
                        // Set scope flag on top-level block scoped symbols
                        if (function.isProgram() &amp;&amp; function.getBody() == block) {
                            symbol.setIsScope();
                        }
                    }
                } else if ((flags &amp; IS_INTERNAL) != 0) {
                    // Always create a new definition.
                    symbol = null;
                } else {
                    // Found LET or CONST in parent scope of same function - s SyntaxError
                    if (symbol.isBlockScoped() &amp;&amp; isLocal(lc.getCurrentFunction(), symbol)) {
                        throwParserException(ECMAErrors.getMessage("syntax.error.redeclare.variable", name), origin);
                    }
                    // Not defined in this function. Create a new definition.
                    if (!isLocal(function, symbol) || symbol.less(IS_VAR)) {
                        symbol = null;
                    }
                }
            }
        }
</source>
    </clone>
    <clone nlines="21" distance="6">
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="189" startcolumn="16" endline="209" endcolumn="9">
if(List.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_LIST_ELEMENT, linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_MAP_ELEMENT, linkerServices);
            collectionType = CollectionType.MAP;
        } else if(clazz.isArray()) {
            gic = getClassGuardedInvocationComponent(linkerServices.filterInternalObjects(MethodHandles.arrayElementGetter(clazz)), callSiteType);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType), Map.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't retrieve elements for objects that are neither arrays, nor list, nor maps.
            return nextComponent;
        }
</source>
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="410" startcolumn="16" endline="432" endcolumn="9">
if(List.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(SET_LIST_ELEMENT, linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(PUT_MAP_ELEMENT, linkerServices);
            collectionType = CollectionType.MAP;
        } else if(clazz.isArray()) {
            gic = getClassGuardedInvocationComponent(linkerServices.filterInternalObjects(
                    MethodHandles.arrayElementSetter(clazz)), callSiteType);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(SET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(PUT_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType),
                    Map.class, ValidationType.INSTANCE_OF, linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't set elements for objects that are neither arrays, nor list, nor maps.
            gic = null;
            collectionType = null;
        }
</source>
    </clone>
    <clone nlines="35" distance="2">
        <source file="jdk/nashorn/internal/objects/NativeJSON.java" startline="375" startcolumn="9" endline="409" endcolumn="9">
if (partial.isEmpty()) {
            finalStr.append("[]");
        } else {
            if (state.gap.isEmpty()) {
                final int size = partial.size();
                index = 0;
                finalStr.append('[');
                for (final Object str : partial) {
                    finalStr.append(str);
                    if (index &lt; size - 1) {
                        finalStr.append(',');
                    }
                    index++;
                }

                finalStr.append(']');
            } else {
                final int size = partial.size();
                index = 0;
                finalStr.append("[\n");
                finalStr.append(state.indent);
                for (final Object str : partial) {
                    finalStr.append(str);
                    if (index &lt; size - 1) {
                        finalStr.append(",\n");
                        finalStr.append(state.indent);
                    }
                    index++;
                }

                finalStr.append('\n');
                finalStr.append(stepback);
                finalStr.append(']');
            }
        }
</source>
        <source file="jdk/nashorn/internal/objects/NativeJSON.java" startline="305" startcolumn="9" endline="343" endcolumn="9">
if (partial.isEmpty()) {
            finalStr.append("{}");
        } else {
            if (state.gap.isEmpty()) {
                final int size = partial.size();
                int       index = 0;

                finalStr.append('{');

                for (final Object str : partial) {
                    finalStr.append(str);
                    if (index &lt; size - 1) {
                        finalStr.append(',');
                    }
                    index++;
                }

                finalStr.append('}');
            } else {
                final int size  = partial.size();
                int       index = 0;

                finalStr.append("{\n");
                finalStr.append(state.indent);

                for (final Object str : partial) {
                    finalStr.append(str);
                    if (index &lt; size - 1) {
                        finalStr.append(",\n");
                        finalStr.append(state.indent);
                    }
                    index++;
                }

                finalStr.append('\n');
                finalStr.append(stepback);
                finalStr.append('}');
            }
        }
</source>
    </clone>
    <clone nlines="40" distance="10">
        <source file="jdk/nashorn/internal/parser/Lexer.java" startline="1171" startcolumn="17" endline="1210" endcolumn="17">
if (ch0 == '&lt;') {
                    if (ch1 == '/' &amp;&amp; Character.isJavaIdentifierStart(ch2)) {
                        skip(3);
                        openCount--;
                    } else if (Character.isJavaIdentifierStart(ch1)) {
                        skip(2);
                        openCount++;
                    } else if (ch1 == '?') {
                        skip(2);
                    } else if (ch1 == '!' &amp;&amp; ch2 == '-' &amp;&amp; ch3 == '-') {
                        skip(4);
                    } else {
                        reset(start);
                        return false;
                    }

                    while (!atEOF() &amp;&amp; ch0 != '&gt;') {
                        if (ch0 == '/' &amp;&amp; ch1 == '&gt;') {
                            openCount--;
                            skip(1);
                            break;
                        } else if (ch0 == '\"' || ch0 == '\'') {
                            scanString(false);
                        } else {
                            skip(1);
                        }
                    }

                    if (ch0 != '&gt;') {
                        reset(start);
                        return false;
                    }

                    skip(1);
                } else if (atEOF()) {
                    reset(start);
                    return false;
                } else {
                    skip(1);
                }
</source>
        <source file="jdk/nashorn/internal/parser/Lexer.java" startline="1170" startcolumn="13" endline="1211" endcolumn="36">
do {
                if (ch0 == '&lt;') {
                    if (ch1 == '/' &amp;&amp; Character.isJavaIdentifierStart(ch2)) {
                        skip(3);
                        openCount--;
                    } else if (Character.isJavaIdentifierStart(ch1)) {
                        skip(2);
                        openCount++;
                    } else if (ch1 == '?') {
                        skip(2);
                    } else if (ch1 == '!' &amp;&amp; ch2 == '-' &amp;&amp; ch3 == '-') {
                        skip(4);
                    } else {
                        reset(start);
                        return false;
                    }

                    while (!atEOF() &amp;&amp; ch0 != '&gt;') {
                        if (ch0 == '/' &amp;&amp; ch1 == '&gt;') {
                            openCount--;
                            skip(1);
                            break;
                        } else if (ch0 == '\"' || ch0 == '\'') {
                            scanString(false);
                        } else {
                            skip(1);
                        }
                    }

                    if (ch0 != '&gt;') {
                        reset(start);
                        return false;
                    }

                    skip(1);
                } else if (atEOF()) {
                    reset(start);
                    return false;
                } else {
                    skip(1);
                }
            } while (openCount &gt; 0);
</source>
    </clone>
    <clone nlines="24" distance="6">
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="186" startcolumn="9" endline="209" endcolumn="9">
if(declaredType.isArray()) {
            gic = createInternalFilteredGuardedInvocationComponent(MethodHandles.arrayElementGetter(declaredType), linkerServices);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_LIST_ELEMENT, linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_MAP_ELEMENT, linkerServices);
            collectionType = CollectionType.MAP;
        } else if(clazz.isArray()) {
            gic = getClassGuardedInvocationComponent(linkerServices.filterInternalObjects(MethodHandles.arrayElementGetter(clazz)), callSiteType);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(GET_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType), Map.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't retrieve elements for objects that are neither arrays, nor list, nor maps.
            return nextComponent;
        }
</source>
        <source file="jdk/internal/dynalink/beans/BeanLinker.java" startline="407" startcolumn="9" endline="432" endcolumn="9">
if(declaredType.isArray()) {
            gic = createInternalFilteredGuardedInvocationComponent(MethodHandles.arrayElementSetter(declaredType), linkerServices);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(SET_LIST_ELEMENT, linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(declaredType)) {
            gic = createInternalFilteredGuardedInvocationComponent(PUT_MAP_ELEMENT, linkerServices);
            collectionType = CollectionType.MAP;
        } else if(clazz.isArray()) {
            gic = getClassGuardedInvocationComponent(linkerServices.filterInternalObjects(
                    MethodHandles.arrayElementSetter(clazz)), callSiteType);
            collectionType = CollectionType.ARRAY;
        } else if(List.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(SET_LIST_ELEMENT, Guards.asType(LIST_GUARD, callSiteType), List.class, ValidationType.INSTANCE_OF,
                    linkerServices);
            collectionType = CollectionType.LIST;
        } else if(Map.class.isAssignableFrom(clazz)) {
            gic = createInternalFilteredGuardedInvocationComponent(PUT_MAP_ELEMENT, Guards.asType(MAP_GUARD, callSiteType),
                    Map.class, ValidationType.INSTANCE_OF, linkerServices);
            collectionType = CollectionType.MAP;
        } else {
            // Can't set elements for objects that are neither arrays, nor list, nor maps.
            gic = null;
            collectionType = null;
        }
</source>
    </clone>
    <clone nlines="42" distance="2">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="784" startcolumn="16" endline="825" endcolumn="9">
while(true) {

        final int type = node.getType();
        if (type == NodeType.QTFR) {
            final QuantifierNode qn = (QuantifierNode)node;
            if (qn.greedy &amp;&amp; isRepeatInfinite(qn.upper)) {
                if (Config.USE_QTFR_PEEK_NEXT) {
                    final StringNode n = (StringNode)getHeadValueNode(nextNode, true);
                    /* '\0': for UTF-16BE etc... */
                    if (n != null &amp;&amp; n.chars[n.p] != 0) { // ?????????
                        qn.nextHeadExact = n;
                    }
                } // USE_QTFR_PEEK_NEXT
                /* automatic posseivation a*b ==&gt; (?&gt;a*)b */
                if (qn.lower &lt;= 1) {
                    if (qn.target.isSimple()) {
                        final Node x = getHeadValueNode(qn.target, false);
                        if (x != null) {
                            final Node y = getHeadValueNode(nextNode, false);
                            if (y != null &amp;&amp; isNotIncluded(x, y)) {
                                final EncloseNode en = new EncloseNode(EncloseType.STOP_BACKTRACK); //onig_node_new_enclose
                                en.setStopBtSimpleRepeat();
                                //en.setTarget(qn.target); // optimize it ??
                                swap(node, en);

                                en.setTarget(node);
                            }
                        }
                    }
                }
            }
        } else if (type == NodeType.ENCLOSE) {
            final EncloseNode en = (EncloseNode)node;
            if (en.isMemory()) {
                node = en.target;
                // !goto retry;!
                continue retry;
            }
        }

        break;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="784" startcolumn="9" endline="825" endcolumn="9">
retry: while(true) {

        final int type = node.getType();
        if (type == NodeType.QTFR) {
            final QuantifierNode qn = (QuantifierNode)node;
            if (qn.greedy &amp;&amp; isRepeatInfinite(qn.upper)) {
                if (Config.USE_QTFR_PEEK_NEXT) {
                    final StringNode n = (StringNode)getHeadValueNode(nextNode, true);
                    /* '\0': for UTF-16BE etc... */
                    if (n != null &amp;&amp; n.chars[n.p] != 0) { // ?????????
                        qn.nextHeadExact = n;
                    }
                } // USE_QTFR_PEEK_NEXT
                /* automatic posseivation a*b ==&gt; (?&gt;a*)b */
                if (qn.lower &lt;= 1) {
                    if (qn.target.isSimple()) {
                        final Node x = getHeadValueNode(qn.target, false);
                        if (x != null) {
                            final Node y = getHeadValueNode(nextNode, false);
                            if (y != null &amp;&amp; isNotIncluded(x, y)) {
                                final EncloseNode en = new EncloseNode(EncloseType.STOP_BACKTRACK); //onig_node_new_enclose
                                en.setStopBtSimpleRepeat();
                                //en.setTarget(qn.target); // optimize it ??
                                swap(node, en);

                                en.setTarget(node);
                            }
                        }
                    }
                }
            }
        } else if (type == NodeType.ENCLOSE) {
            final EncloseNode en = (EncloseNode)node;
            if (en.isMemory()) {
                node = en.target;
                // !goto retry;!
                continue retry;
            }
        }

        break;
        }
</source>
    </clone>
    <clone nlines="18" distance="2">
        <source file="jdk/nashorn/internal/runtime/ScriptFunctionData.java" startline="693" startcolumn="13" endline="710" endcolumn="13">
switch (paramCount) {
            case 1:
                return mh.invokeExact(fn);
            case 2:
                return mh.invokeExact(fn, getArg(args, 0));
            case 3:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1));
            case 4:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2));
            case 5:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3));
            case 6:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4));
            case 7:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4), getArg(args, 5));
            default:
                return mh.invokeWithArguments(withArguments(fn, paramCount, args));
            }
</source>
        <source file="jdk/nashorn/internal/runtime/ScriptFunctionData.java" startline="658" startcolumn="9" endline="675" endcolumn="9">
switch (paramCount) {
        case 1:
            return mh.invokeExact(selfObj);
        case 2:
            return mh.invokeExact(selfObj, getArg(args, 0));
        case 3:
            return mh.invokeExact(selfObj, getArg(args, 0), getArg(args, 1));
        case 4:
            return mh.invokeExact(selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2));
        case 5:
            return mh.invokeExact(selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3));
        case 6:
            return mh.invokeExact(selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4));
        case 7:
            return mh.invokeExact(selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4), getArg(args, 5));
        default:
            return mh.invokeWithArguments(withArguments(null, selfObj, paramCount, args));
        }
</source>
    </clone>
    <clone nlines="18" distance="9">
        <source file="jdk/nashorn/internal/runtime/ScriptFunctionData.java" startline="693" startcolumn="13" endline="710" endcolumn="13">
switch (paramCount) {
            case 1:
                return mh.invokeExact(fn);
            case 2:
                return mh.invokeExact(fn, getArg(args, 0));
            case 3:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1));
            case 4:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2));
            case 5:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3));
            case 6:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4));
            case 7:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4), getArg(args, 5));
            default:
                return mh.invokeWithArguments(withArguments(fn, paramCount, args));
            }
</source>
        <source file="jdk/nashorn/internal/runtime/ScriptFunctionData.java" startline="692" startcolumn="9" endline="711" endcolumn="9">
if (needsCallee(mh)) {
            switch (paramCount) {
            case 1:
                return mh.invokeExact(fn);
            case 2:
                return mh.invokeExact(fn, getArg(args, 0));
            case 3:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1));
            case 4:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2));
            case 5:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3));
            case 6:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4));
            case 7:
                return mh.invokeExact(fn, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4), getArg(args, 5));
            default:
                return mh.invokeWithArguments(withArguments(fn, paramCount, args));
            }
        }
</source>
    </clone>
    <clone nlines="18" distance="9">
        <source file="jdk/nashorn/internal/runtime/ScriptFunctionData.java" startline="638" startcolumn="13" endline="655" endcolumn="13">
switch (paramCount) {
            case 2:
                return mh.invokeExact(fn, selfObj);
            case 3:
                return mh.invokeExact(fn, selfObj, getArg(args, 0));
            case 4:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1));
            case 5:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2));
            case 6:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3));
            case 7:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4));
            case 8:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4), getArg(args, 5));
            default:
                return mh.invokeWithArguments(withArguments(fn, selfObj, paramCount, args));
            }
</source>
        <source file="jdk/nashorn/internal/runtime/ScriptFunctionData.java" startline="637" startcolumn="9" endline="656" endcolumn="9">
if (needsCallee(mh)) {
            switch (paramCount) {
            case 2:
                return mh.invokeExact(fn, selfObj);
            case 3:
                return mh.invokeExact(fn, selfObj, getArg(args, 0));
            case 4:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1));
            case 5:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2));
            case 6:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3));
            case 7:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4));
            case 8:
                return mh.invokeExact(fn, selfObj, getArg(args, 0), getArg(args, 1), getArg(args, 2), getArg(args, 3), getArg(args, 4), getArg(args, 5));
            default:
                return mh.invokeWithArguments(withArguments(fn, selfObj, paramCount, args));
            }
        }
</source>
    </clone>
    <clone nlines="70" distance="10">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="767" startcolumn="13" endline="836" endcolumn="13">
while (type != EOF) {
                // Break if the end of a code block.
                if (type == RBRACE) {
                    break;
                }

                try {
                    // Get the next element.
                    statement(true, allowPropertyFunction, false);
                    allowPropertyFunction = false;

                    // check for directive prologues
                    if (checkDirective) {
                        // skip any debug statement like line number to get actual first line
                        final Node lastStatement = lc.getLastStatement();

                        // get directive prologue, if any
                        final String directive = getDirective(lastStatement);

                        // If we have seen first non-directive statement,
                        // no more directive statements!!
                        checkDirective = directive != null;

                        if (checkDirective) {
                            if (!oldStrictMode) {
                                if (directiveStmts == null) {
                                    directiveStmts = new ArrayList&lt;&gt;();
                                }
                                directiveStmts.add(lastStatement);
                            }

                            // handle use strict directive
                            if ("use strict".equals(directive)) {
                                isStrictMode = true;
                                final FunctionNode function = lc.getCurrentFunction();
                                lc.setFlag(lc.getCurrentFunction(), FunctionNode.IS_STRICT);

                                // We don't need to check these, if lexical environment is already strict
                                if (!oldStrictMode &amp;&amp; directiveStmts != null) {
                                    // check that directives preceding this one do not violate strictness
                                    for (final Node statement : directiveStmts) {
                                        // the get value will force unescape of preceeding
                                        // escaped string directives
                                        getValue(statement.getToken());
                                    }

                                    // verify that function name as well as parameter names
                                    // satisfy strict mode restrictions.
                                    verifyStrictIdent(function.getIdent(), "function name");
                                    for (final IdentNode param : function.getParameters()) {
                                        verifyStrictIdent(param, "function parameter");
                                    }
                                }
                            } else if (Context.DEBUG) {
                                final int flag = FunctionNode.getDirectiveFlag(directive);
                                if (flag != 0) {
                                    final FunctionNode function = lc.getCurrentFunction();
                                    lc.setFlag(function, flag);
                                }
                            }
                        }
                    }
                } catch (final Exception e) {
                    //recover parsing
                    recover(e);
                }

                // No backtracking from here on.
                stream.commit(k);
            }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="765" startcolumn="9" endline="839" endcolumn="9">
try {
            // If is a script, then process until the end of the script.
            while (type != EOF) {
                // Break if the end of a code block.
                if (type == RBRACE) {
                    break;
                }

                try {
                    // Get the next element.
                    statement(true, allowPropertyFunction, false);
                    allowPropertyFunction = false;

                    // check for directive prologues
                    if (checkDirective) {
                        // skip any debug statement like line number to get actual first line
                        final Node lastStatement = lc.getLastStatement();

                        // get directive prologue, if any
                        final String directive = getDirective(lastStatement);

                        // If we have seen first non-directive statement,
                        // no more directive statements!!
                        checkDirective = directive != null;

                        if (checkDirective) {
                            if (!oldStrictMode) {
                                if (directiveStmts == null) {
                                    directiveStmts = new ArrayList&lt;&gt;();
                                }
                                directiveStmts.add(lastStatement);
                            }

                            // handle use strict directive
                            if ("use strict".equals(directive)) {
                                isStrictMode = true;
                                final FunctionNode function = lc.getCurrentFunction();
                                lc.setFlag(lc.getCurrentFunction(), FunctionNode.IS_STRICT);

                                // We don't need to check these, if lexical environment is already strict
                                if (!oldStrictMode &amp;&amp; directiveStmts != null) {
                                    // check that directives preceding this one do not violate strictness
                                    for (final Node statement : directiveStmts) {
                                        // the get value will force unescape of preceeding
                                        // escaped string directives
                                        getValue(statement.getToken());
                                    }

                                    // verify that function name as well as parameter names
                                    // satisfy strict mode restrictions.
                                    verifyStrictIdent(function.getIdent(), "function name");
                                    for (final IdentNode param : function.getParameters()) {
                                        verifyStrictIdent(param, "function parameter");
                                    }
                                }
                            } else if (Context.DEBUG) {
                                final int flag = FunctionNode.getDirectiveFlag(directive);
                                if (flag != 0) {
                                    final FunctionNode function = lc.getCurrentFunction();
                                    lc.setFlag(function, flag);
                                }
                            }
                        }
                    }
                } catch (final Exception e) {
                    //recover parsing
                    recover(e);
                }

                // No backtracking from here on.
                stream.commit(k);
            }
        } finally {
            isStrictMode = oldStrictMode;
        }
</source>
    </clone>
    <clone nlines="62" distance="2">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Matcher.java" startline="208" startcolumn="15" endline="269" endcolumn="9">
while (true) {
            p = regex.searchAlgorithm.searchBackward(regex, ch, r, adjrange, e, p, s, r);

            if (p != -1) {
                if (regex.subAnchor != 0) {
                    switch (regex.subAnchor) {
                    case AnchorType.BEGIN_LINE:
                        if (p != string) {
                            final int prev = EncodingHelper.prevCharHead(string, p);
                            if (!EncodingHelper.isNewLine(ch, prev, e)) {
                                p = prev;
                                continue retry;
                            }
                        }
                        break;

                    case AnchorType.END_LINE:
                        if (p == e) {
                            if (!Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                                final int prev = EncodingHelper.prevCharHead(adjrange, p);
                                if (prev == -1) {
                                    return false;
                                }
                                if (EncodingHelper.isNewLine(ch, prev, e)) {
                                    p = prev;
                                    continue retry;
                                }
                            }
                        } else if (!EncodingHelper.isNewLine(ch, p, e)) {
                            p = EncodingHelper.prevCharHead(adjrange, p);
                            if (p == -1) {
                                return false;
                            }
                            continue retry;
                        }
                        break;

                    default:
                        break;
                    } // switch
                }

                /* no needs to adjust *high, *high is used as range check only */
                if (regex.dMax != MinMaxLen.INFINITE_DISTANCE) {
                    low = p - regex.dMax;
                    high = p - regex.dMin;
                }

                if (Config.DEBUG_SEARCH) {
                    Config.log.println("backward_search_range: "+
                                        "low: " + (low - string) +
                                        ", high: " + (high - string));
                }

                return true;
            }

            if (Config.DEBUG_SEARCH) {
                Config.log.println("backward_search_range: fail.");
            }
            return false;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Matcher.java" startline="208" startcolumn="9" endline="269" endcolumn="9">
retry:while (true) {
            p = regex.searchAlgorithm.searchBackward(regex, ch, r, adjrange, e, p, s, r);

            if (p != -1) {
                if (regex.subAnchor != 0) {
                    switch (regex.subAnchor) {
                    case AnchorType.BEGIN_LINE:
                        if (p != string) {
                            final int prev = EncodingHelper.prevCharHead(string, p);
                            if (!EncodingHelper.isNewLine(ch, prev, e)) {
                                p = prev;
                                continue retry;
                            }
                        }
                        break;

                    case AnchorType.END_LINE:
                        if (p == e) {
                            if (!Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                                final int prev = EncodingHelper.prevCharHead(adjrange, p);
                                if (prev == -1) {
                                    return false;
                                }
                                if (EncodingHelper.isNewLine(ch, prev, e)) {
                                    p = prev;
                                    continue retry;
                                }
                            }
                        } else if (!EncodingHelper.isNewLine(ch, p, e)) {
                            p = EncodingHelper.prevCharHead(adjrange, p);
                            if (p == -1) {
                                return false;
                            }
                            continue retry;
                        }
                        break;

                    default:
                        break;
                    } // switch
                }

                /* no needs to adjust *high, *high is used as range check only */
                if (regex.dMax != MinMaxLen.INFINITE_DISTANCE) {
                    low = p - regex.dMax;
                    high = p - regex.dMin;
                }

                if (Config.DEBUG_SEARCH) {
                    Config.log.println("backward_search_range: "+
                                        "low: " + (low - string) +
                                        ", high: " + (high - string));
                }

                return true;
            }

            if (Config.DEBUG_SEARCH) {
                Config.log.println("backward_search_range: fail.");
            }
            return false;
        }
</source>
    </clone>
    <clone nlines="110" distance="8">
        <source file="jdk/nashorn/internal/parser/Lexer.java" startline="831" startcolumn="13" endline="940" endcolumn="13">
if (ch0 == '\\') {
                skip(1);

                final char next = ch0;
                final int afterSlash = position;

                skip(1);

                // Special characters.
                switch (next) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7': {
                    if (strict) {
                        // "\0" itself is allowed in strict mode. Only other 'real'
                        // octal escape sequences are not allowed (eg. "\02", "\31").
                        // See section 7.8.4 String literals production EscapeSequence
                        if (next != '0' || (ch0 &gt;= '0' &amp;&amp; ch0 &lt;= '9')) {
                            error(Lexer.message("strict.no.octal"), STRING, position, limit);
                        }
                    }
                    reset(afterSlash);
                    // Octal sequence.
                    final int ch = octalSequence();

                    if (ch &lt; 0) {
                        sb.append('\\');
                        sb.append('x');
                    } else {
                        sb.append((char)ch);
                    }
                    break;
                }
                case 'n':
                    sb.append('\n');
                    break;
                case 't':
                    sb.append('\t');
                    break;
                case 'b':
                    sb.append('\b');
                    break;
                case 'f':
                    sb.append('\f');
                    break;
                case 'r':
                    sb.append('\r');
                    break;
                case '\'':
                    sb.append('\'');
                    break;
                case '\"':
                    sb.append('\"');
                    break;
                case '\\':
                    sb.append('\\');
                    break;
                case '\r': // CR | CRLF
                    if (ch0 == '\n') {
                        skip(1);
                    }
                    // fall through
                case '\n': // LF
                case '\u2028': // LS
                case '\u2029': // PS
                    // continue on the next line, slash-return continues string
                    // literal
                    break;
                case 'x': {
                    // Hex sequence.
                    final int ch = hexSequence(2, STRING);

                    if (ch &lt; 0) {
                        sb.append('\\');
                        sb.append('x');
                    } else {
                        sb.append((char)ch);
                    }
                }
                    break;
                case 'u': {
                    // Unicode sequence.
                    final int ch = hexSequence(4, STRING);

                    if (ch &lt; 0) {
                        sb.append('\\');
                        sb.append('u');
                    } else {
                        sb.append((char)ch);
                    }
                }
                    break;
                case 'v':
                    sb.append('\u000B');
                    break;
                // All other characters.
                default:
                    sb.append(next);
                    break;
                }
            } else {
                // Add regular character.
                sb.append(ch0);
                skip(1);
            }
</source>
        <source file="jdk/nashorn/internal/parser/Lexer.java" startline="829" startcolumn="9" endline="941" endcolumn="9">
while (position &lt; end) {
            // If escape character.
            if (ch0 == '\\') {
                skip(1);

                final char next = ch0;
                final int afterSlash = position;

                skip(1);

                // Special characters.
                switch (next) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7': {
                    if (strict) {
                        // "\0" itself is allowed in strict mode. Only other 'real'
                        // octal escape sequences are not allowed (eg. "\02", "\31").
                        // See section 7.8.4 String literals production EscapeSequence
                        if (next != '0' || (ch0 &gt;= '0' &amp;&amp; ch0 &lt;= '9')) {
                            error(Lexer.message("strict.no.octal"), STRING, position, limit);
                        }
                    }
                    reset(afterSlash);
                    // Octal sequence.
                    final int ch = octalSequence();

                    if (ch &lt; 0) {
                        sb.append('\\');
                        sb.append('x');
                    } else {
                        sb.append((char)ch);
                    }
                    break;
                }
                case 'n':
                    sb.append('\n');
                    break;
                case 't':
                    sb.append('\t');
                    break;
                case 'b':
                    sb.append('\b');
                    break;
                case 'f':
                    sb.append('\f');
                    break;
                case 'r':
                    sb.append('\r');
                    break;
                case '\'':
                    sb.append('\'');
                    break;
                case '\"':
                    sb.append('\"');
                    break;
                case '\\':
                    sb.append('\\');
                    break;
                case '\r': // CR | CRLF
                    if (ch0 == '\n') {
                        skip(1);
                    }
                    // fall through
                case '\n': // LF
                case '\u2028': // LS
                case '\u2029': // PS
                    // continue on the next line, slash-return continues string
                    // literal
                    break;
                case 'x': {
                    // Hex sequence.
                    final int ch = hexSequence(2, STRING);

                    if (ch &lt; 0) {
                        sb.append('\\');
                        sb.append('x');
                    } else {
                        sb.append((char)ch);
                    }
                }
                    break;
                case 'u': {
                    // Unicode sequence.
                    final int ch = hexSequence(4, STRING);

                    if (ch &lt; 0) {
                        sb.append('\\');
                        sb.append('u');
                    } else {
                        sb.append((char)ch);
                    }
                }
                    break;
                case 'v':
                    sb.append('\u000B');
                    break;
                // All other characters.
                default:
                    sb.append(next);
                    break;
                }
            } else {
                // Add regular character.
                sb.append(ch0);
                skip(1);
            }
        }
</source>
    </clone>
    <clone nlines="76" distance="6">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2137" startcolumn="13" endline="2212" endcolumn="13">
switch (type) {
                case RBRACE:
                    next();
                    break loop;

                case COMMARIGHT:
                    if (commaSeen) {
                        throw error(AbstractParser.message("expected.property.id", type.getNameOrType()));
                    }
                    next();
                    commaSeen = true;
                    break;

                default:
                    if (!commaSeen) {
                        throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                    }

                    commaSeen = false;
                    // Get and add the next property.
                    final PropertyNode property = propertyAssignment();
                    final String key = property.getKeyName();
                    final Integer existing = map.get(key);

                    if (existing == null) {
                        map.put(key, elements.size());
                        elements.add(property);
                        break;
                    }

                    final PropertyNode existingProperty = elements.get(existing);

                    // ECMA section 11.1.5 Object Initialiser
                    // point # 4 on property assignment production
                    final Expression   value  = property.getValue();
                    final FunctionNode getter = property.getGetter();
                    final FunctionNode setter = property.getSetter();

                    final Expression   prevValue  = existingProperty.getValue();
                    final FunctionNode prevGetter = existingProperty.getGetter();
                    final FunctionNode prevSetter = existingProperty.getSetter();

                    // ECMA 11.1.5 strict mode restrictions
                    if (isStrictMode &amp;&amp; value != null &amp;&amp; prevValue != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    final boolean isPrevAccessor = prevGetter != null || prevSetter != null;
                    final boolean isAccessor     = getter != null     || setter != null;

                    // data property redefined as accessor property
                    if (prevValue != null &amp;&amp; isAccessor) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    // accessor property redefined as data
                    if (isPrevAccessor &amp;&amp; value != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    if (isAccessor &amp;&amp; isPrevAccessor) {
                        if (getter != null &amp;&amp; prevGetter != null ||
                                setter != null &amp;&amp; prevSetter != null) {
                            throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                        }
                    }

                    if (value != null) {
                        elements.add(property);
                    } else if (getter != null) {
                        elements.set(existing, existingProperty.setGetter(getter));
                    } else if (setter != null) {
                        elements.set(existing, existingProperty.setSetter(setter));
                    }
                    break;
            }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2136" startcolumn="9" endline="2213" endcolumn="9">
while (true) {
            switch (type) {
                case RBRACE:
                    next();
                    break loop;

                case COMMARIGHT:
                    if (commaSeen) {
                        throw error(AbstractParser.message("expected.property.id", type.getNameOrType()));
                    }
                    next();
                    commaSeen = true;
                    break;

                default:
                    if (!commaSeen) {
                        throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                    }

                    commaSeen = false;
                    // Get and add the next property.
                    final PropertyNode property = propertyAssignment();
                    final String key = property.getKeyName();
                    final Integer existing = map.get(key);

                    if (existing == null) {
                        map.put(key, elements.size());
                        elements.add(property);
                        break;
                    }

                    final PropertyNode existingProperty = elements.get(existing);

                    // ECMA section 11.1.5 Object Initialiser
                    // point # 4 on property assignment production
                    final Expression   value  = property.getValue();
                    final FunctionNode getter = property.getGetter();
                    final FunctionNode setter = property.getSetter();

                    final Expression   prevValue  = existingProperty.getValue();
                    final FunctionNode prevGetter = existingProperty.getGetter();
                    final FunctionNode prevSetter = existingProperty.getSetter();

                    // ECMA 11.1.5 strict mode restrictions
                    if (isStrictMode &amp;&amp; value != null &amp;&amp; prevValue != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    final boolean isPrevAccessor = prevGetter != null || prevSetter != null;
                    final boolean isAccessor     = getter != null     || setter != null;

                    // data property redefined as accessor property
                    if (prevValue != null &amp;&amp; isAccessor) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    // accessor property redefined as data
                    if (isPrevAccessor &amp;&amp; value != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    if (isAccessor &amp;&amp; isPrevAccessor) {
                        if (getter != null &amp;&amp; prevGetter != null ||
                                setter != null &amp;&amp; prevSetter != null) {
                            throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                        }
                    }

                    if (value != null) {
                        elements.add(property);
                    } else if (getter != null) {
                        elements.set(existing, existingProperty.setGetter(getter));
                    } else if (setter != null) {
                        elements.set(existing, existingProperty.setSetter(setter));
                    }
                    break;
            }
        }
</source>
    </clone>
    <clone nlines="76" distance="8">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2137" startcolumn="13" endline="2212" endcolumn="13">
switch (type) {
                case RBRACE:
                    next();
                    break loop;

                case COMMARIGHT:
                    if (commaSeen) {
                        throw error(AbstractParser.message("expected.property.id", type.getNameOrType()));
                    }
                    next();
                    commaSeen = true;
                    break;

                default:
                    if (!commaSeen) {
                        throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                    }

                    commaSeen = false;
                    // Get and add the next property.
                    final PropertyNode property = propertyAssignment();
                    final String key = property.getKeyName();
                    final Integer existing = map.get(key);

                    if (existing == null) {
                        map.put(key, elements.size());
                        elements.add(property);
                        break;
                    }

                    final PropertyNode existingProperty = elements.get(existing);

                    // ECMA section 11.1.5 Object Initialiser
                    // point # 4 on property assignment production
                    final Expression   value  = property.getValue();
                    final FunctionNode getter = property.getGetter();
                    final FunctionNode setter = property.getSetter();

                    final Expression   prevValue  = existingProperty.getValue();
                    final FunctionNode prevGetter = existingProperty.getGetter();
                    final FunctionNode prevSetter = existingProperty.getSetter();

                    // ECMA 11.1.5 strict mode restrictions
                    if (isStrictMode &amp;&amp; value != null &amp;&amp; prevValue != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    final boolean isPrevAccessor = prevGetter != null || prevSetter != null;
                    final boolean isAccessor     = getter != null     || setter != null;

                    // data property redefined as accessor property
                    if (prevValue != null &amp;&amp; isAccessor) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    // accessor property redefined as data
                    if (isPrevAccessor &amp;&amp; value != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    if (isAccessor &amp;&amp; isPrevAccessor) {
                        if (getter != null &amp;&amp; prevGetter != null ||
                                setter != null &amp;&amp; prevSetter != null) {
                            throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                        }
                    }

                    if (value != null) {
                        elements.add(property);
                    } else if (getter != null) {
                        elements.set(existing, existingProperty.setGetter(getter));
                    } else if (setter != null) {
                        elements.set(existing, existingProperty.setSetter(setter));
                    }
                    break;
            }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2135" startcolumn="1" endline="2213" endcolumn="9">
loop:
        while (true) {
            switch (type) {
                case RBRACE:
                    next();
                    break loop;

                case COMMARIGHT:
                    if (commaSeen) {
                        throw error(AbstractParser.message("expected.property.id", type.getNameOrType()));
                    }
                    next();
                    commaSeen = true;
                    break;

                default:
                    if (!commaSeen) {
                        throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                    }

                    commaSeen = false;
                    // Get and add the next property.
                    final PropertyNode property = propertyAssignment();
                    final String key = property.getKeyName();
                    final Integer existing = map.get(key);

                    if (existing == null) {
                        map.put(key, elements.size());
                        elements.add(property);
                        break;
                    }

                    final PropertyNode existingProperty = elements.get(existing);

                    // ECMA section 11.1.5 Object Initialiser
                    // point # 4 on property assignment production
                    final Expression   value  = property.getValue();
                    final FunctionNode getter = property.getGetter();
                    final FunctionNode setter = property.getSetter();

                    final Expression   prevValue  = existingProperty.getValue();
                    final FunctionNode prevGetter = existingProperty.getGetter();
                    final FunctionNode prevSetter = existingProperty.getSetter();

                    // ECMA 11.1.5 strict mode restrictions
                    if (isStrictMode &amp;&amp; value != null &amp;&amp; prevValue != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    final boolean isPrevAccessor = prevGetter != null || prevSetter != null;
                    final boolean isAccessor     = getter != null     || setter != null;

                    // data property redefined as accessor property
                    if (prevValue != null &amp;&amp; isAccessor) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    // accessor property redefined as data
                    if (isPrevAccessor &amp;&amp; value != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    if (isAccessor &amp;&amp; isPrevAccessor) {
                        if (getter != null &amp;&amp; prevGetter != null ||
                                setter != null &amp;&amp; prevSetter != null) {
                            throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                        }
                    }

                    if (value != null) {
                        elements.add(property);
                    } else if (getter != null) {
                        elements.set(existing, existingProperty.setGetter(getter));
                    } else if (setter != null) {
                        elements.set(existing, existingProperty.setSetter(setter));
                    }
                    break;
            }
        }
</source>
    </clone>
    <clone nlines="78" distance="2">
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2136" startcolumn="9" endline="2213" endcolumn="9">
while (true) {
            switch (type) {
                case RBRACE:
                    next();
                    break loop;

                case COMMARIGHT:
                    if (commaSeen) {
                        throw error(AbstractParser.message("expected.property.id", type.getNameOrType()));
                    }
                    next();
                    commaSeen = true;
                    break;

                default:
                    if (!commaSeen) {
                        throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                    }

                    commaSeen = false;
                    // Get and add the next property.
                    final PropertyNode property = propertyAssignment();
                    final String key = property.getKeyName();
                    final Integer existing = map.get(key);

                    if (existing == null) {
                        map.put(key, elements.size());
                        elements.add(property);
                        break;
                    }

                    final PropertyNode existingProperty = elements.get(existing);

                    // ECMA section 11.1.5 Object Initialiser
                    // point # 4 on property assignment production
                    final Expression   value  = property.getValue();
                    final FunctionNode getter = property.getGetter();
                    final FunctionNode setter = property.getSetter();

                    final Expression   prevValue  = existingProperty.getValue();
                    final FunctionNode prevGetter = existingProperty.getGetter();
                    final FunctionNode prevSetter = existingProperty.getSetter();

                    // ECMA 11.1.5 strict mode restrictions
                    if (isStrictMode &amp;&amp; value != null &amp;&amp; prevValue != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    final boolean isPrevAccessor = prevGetter != null || prevSetter != null;
                    final boolean isAccessor     = getter != null     || setter != null;

                    // data property redefined as accessor property
                    if (prevValue != null &amp;&amp; isAccessor) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    // accessor property redefined as data
                    if (isPrevAccessor &amp;&amp; value != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    if (isAccessor &amp;&amp; isPrevAccessor) {
                        if (getter != null &amp;&amp; prevGetter != null ||
                                setter != null &amp;&amp; prevSetter != null) {
                            throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                        }
                    }

                    if (value != null) {
                        elements.add(property);
                    } else if (getter != null) {
                        elements.set(existing, existingProperty.setGetter(getter));
                    } else if (setter != null) {
                        elements.set(existing, existingProperty.setSetter(setter));
                    }
                    break;
            }
        }
</source>
        <source file="jdk/nashorn/internal/parser/Parser.java" startline="2135" startcolumn="1" endline="2213" endcolumn="9">
loop:
        while (true) {
            switch (type) {
                case RBRACE:
                    next();
                    break loop;

                case COMMARIGHT:
                    if (commaSeen) {
                        throw error(AbstractParser.message("expected.property.id", type.getNameOrType()));
                    }
                    next();
                    commaSeen = true;
                    break;

                default:
                    if (!commaSeen) {
                        throw error(AbstractParser.message("expected.comma", type.getNameOrType()));
                    }

                    commaSeen = false;
                    // Get and add the next property.
                    final PropertyNode property = propertyAssignment();
                    final String key = property.getKeyName();
                    final Integer existing = map.get(key);

                    if (existing == null) {
                        map.put(key, elements.size());
                        elements.add(property);
                        break;
                    }

                    final PropertyNode existingProperty = elements.get(existing);

                    // ECMA section 11.1.5 Object Initialiser
                    // point # 4 on property assignment production
                    final Expression   value  = property.getValue();
                    final FunctionNode getter = property.getGetter();
                    final FunctionNode setter = property.getSetter();

                    final Expression   prevValue  = existingProperty.getValue();
                    final FunctionNode prevGetter = existingProperty.getGetter();
                    final FunctionNode prevSetter = existingProperty.getSetter();

                    // ECMA 11.1.5 strict mode restrictions
                    if (isStrictMode &amp;&amp; value != null &amp;&amp; prevValue != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    final boolean isPrevAccessor = prevGetter != null || prevSetter != null;
                    final boolean isAccessor     = getter != null     || setter != null;

                    // data property redefined as accessor property
                    if (prevValue != null &amp;&amp; isAccessor) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    // accessor property redefined as data
                    if (isPrevAccessor &amp;&amp; value != null) {
                        throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                    }

                    if (isAccessor &amp;&amp; isPrevAccessor) {
                        if (getter != null &amp;&amp; prevGetter != null ||
                                setter != null &amp;&amp; prevSetter != null) {
                            throw error(AbstractParser.message("property.redefinition", key), property.getToken());
                        }
                    }

                    if (value != null) {
                        elements.add(property);
                    } else if (getter != null) {
                        elements.set(existing, existingProperty.setGetter(getter));
                    } else if (setter != null) {
                        elements.set(existing, existingProperty.setSetter(setter));
                    }
                    break;
            }
        }
</source>
    </clone>
    <clone nlines="106" distance="2">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="486" startcolumn="16" endline="591" endcolumn="9">
while(true) {

        final int yType = y.getType();

        switch(x.getType()) {
        case NodeType.CTYPE:
            switch(yType) {

            case NodeType.CCLASS:
                // !swap:!
                tmp = x;
                x = y;
                y = tmp;
                // !goto retry;!
                continue retry;

            case NodeType.STR:
                // !goto swap;!
                tmp = x;
                x = y;
                y = tmp;
                continue retry;

            default:
                break;
            } // inner switch
            break;

        case NodeType.CCLASS:
            final CClassNode xc = (CClassNode)x;

            switch(yType) {

            case NodeType.CCLASS:
                final CClassNode yc = (CClassNode)y;

                for (int i=0; i&lt;BitSet.SINGLE_BYTE_SIZE; i++) {
                    boolean v = xc.bs.at(i);
                    if ((v &amp;&amp; !xc.isNot()) || (!v &amp;&amp; xc.isNot())) {
                        v = yc.bs.at(i);
                        if ((v &amp;&amp; !yc.isNot()) || (!v &amp;&amp; yc.isNot())) {
                            return false;
                        }
                    }
                }
                if ((xc.mbuf == null &amp;&amp; !xc.isNot()) || yc.mbuf == null &amp;&amp; !yc.isNot()) {
                    return true;
                }
                return false;
                // break; not reached

            case NodeType.STR:
                // !goto swap;!
                tmp = x;
                x = y;
                y = tmp;
                continue retry;

            default:
                break;

            } // inner switch
            break; // case NodeType.CCLASS

        case NodeType.STR:
            final StringNode xs = (StringNode)x;
            if (xs.length() == 0) {
                break;
            }

            switch (yType) {

            case NodeType.CCLASS:
                final CClassNode cc = (CClassNode)y;
                final int code = xs.chars[xs.p];
                return !cc.isCodeInCC(code);

            case NodeType.STR:
                final StringNode ys = (StringNode)y;
                int len = xs.length();
                if (len &gt; ys.length()) {
                    len = ys.length();
                }
                if (xs.isAmbig() || ys.isAmbig()) {
                    /* tiny version */
                    return false;
                }
                for (int i=0, pt=ys.p, q=xs.p; i&lt;len; i++, pt++, q++) {
                    if (ys.chars[pt] != xs.chars[q]) {
                        return true;
                    }
                }
                break;

            default:
                break;
            } // inner switch

            break; // case NodeType.STR
        default:
            break;

        } // switch

        break;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="486" startcolumn="9" endline="591" endcolumn="9">
retry: while(true) {

        final int yType = y.getType();

        switch(x.getType()) {
        case NodeType.CTYPE:
            switch(yType) {

            case NodeType.CCLASS:
                // !swap:!
                tmp = x;
                x = y;
                y = tmp;
                // !goto retry;!
                continue retry;

            case NodeType.STR:
                // !goto swap;!
                tmp = x;
                x = y;
                y = tmp;
                continue retry;

            default:
                break;
            } // inner switch
            break;

        case NodeType.CCLASS:
            final CClassNode xc = (CClassNode)x;

            switch(yType) {

            case NodeType.CCLASS:
                final CClassNode yc = (CClassNode)y;

                for (int i=0; i&lt;BitSet.SINGLE_BYTE_SIZE; i++) {
                    boolean v = xc.bs.at(i);
                    if ((v &amp;&amp; !xc.isNot()) || (!v &amp;&amp; xc.isNot())) {
                        v = yc.bs.at(i);
                        if ((v &amp;&amp; !yc.isNot()) || (!v &amp;&amp; yc.isNot())) {
                            return false;
                        }
                    }
                }
                if ((xc.mbuf == null &amp;&amp; !xc.isNot()) || yc.mbuf == null &amp;&amp; !yc.isNot()) {
                    return true;
                }
                return false;
                // break; not reached

            case NodeType.STR:
                // !goto swap;!
                tmp = x;
                x = y;
                y = tmp;
                continue retry;

            default:
                break;

            } // inner switch
            break; // case NodeType.CCLASS

        case NodeType.STR:
            final StringNode xs = (StringNode)x;
            if (xs.length() == 0) {
                break;
            }

            switch (yType) {

            case NodeType.CCLASS:
                final CClassNode cc = (CClassNode)y;
                final int code = xs.chars[xs.p];
                return !cc.isCodeInCC(code);

            case NodeType.STR:
                final StringNode ys = (StringNode)y;
                int len = xs.length();
                if (len &gt; ys.length()) {
                    len = ys.length();
                }
                if (xs.isAmbig() || ys.isAmbig()) {
                    /* tiny version */
                    return false;
                }
                for (int i=0, pt=ys.p, q=xs.p; i&lt;len; i++, pt++, q++) {
                    if (ys.chars[pt] != xs.chars[q]) {
                        return true;
                    }
                }
                break;

            default:
                break;
            } // inner switch

            break; // case NodeType.STR
        default:
            break;

        } // switch

        break;
        }
</source>
    </clone>
    <clone nlines="91" distance="2">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Matcher.java" startline="109" startcolumn="15" endline="199" endcolumn="9">
while (true) {
            p = regex.searchAlgorithm.search(regex, ch, p, e, range);

            if (p != -1 &amp;&amp; p &lt; range) {
                if (p - regex.dMin &lt; s) {
                    // retry_gate:
                    pprev = p;
                    p++;
                    continue retry;
                }

                if (regex.subAnchor != 0) {
                    switch (regex.subAnchor) {
                    case AnchorType.BEGIN_LINE:
                        if (p != string) {
                            final int prev = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                            if (!EncodingHelper.isNewLine(ch, prev, e)) {
                                // goto retry_gate;
                                pprev = p;
                                p++;
                                continue retry;
                            }
                        }
                        break;

                    case AnchorType.END_LINE:
                        if (p == e) {
                            if (!Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                                final int prev = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                                if (prev != -1 &amp;&amp; EncodingHelper.isNewLine(ch, prev, e)) {
                                    // goto retry_gate;
                                    pprev = p;
                                    p++;
                                    continue retry;
                                }
                            }
                        } else if (!EncodingHelper.isNewLine(ch, p, e)) {
                            //if () break;
                            // goto retry_gate;
                            pprev = p;
                            p++;
                            continue retry;
                        }
                        break;

                    default:
                        break;
                    } // switch
                }

                if (regex.dMax == 0) {
                    low = p;
                    if (lowPrev != null) { // ??? // remove null checks
                        if (low &gt; s) {
                            lowPrev.value = EncodingHelper.prevCharHead(s, p);
                        } else {
                            lowPrev.value = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                        }
                    }
                } else {
                    if (regex.dMax != MinMaxLen.INFINITE_DISTANCE) {
                        low = p - regex.dMax;

                        if (low &gt; s) {
                            low = EncodingHelper.rightAdjustCharHeadWithPrev(low, lowPrev);
                            if (lowPrev != null &amp;&amp; lowPrev.value == -1) {
                                lowPrev.value = EncodingHelper.prevCharHead((pprev != -1) ? pprev : s, low);
                            }
                        } else {
                            if (lowPrev != null) {
                                lowPrev.value = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, low);
                            }
                        }
                    }
                }
                /* no needs to adjust *high, *high is used as range check only */
                high = p - regex.dMin;

                if (Config.DEBUG_SEARCH) {
                    Config.log.println("forward_search_range success: "+
                                        "low: " + (low - string) +
                                        ", high: " + (high - string) +
                                        ", dmin: " + regex.dMin +
                                        ", dmax: " + regex.dMax);
                }

                return true;    /* success */
            }

            return false;   /* fail */
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Matcher.java" startline="109" startcolumn="9" endline="199" endcolumn="9">
retry:while (true) {
            p = regex.searchAlgorithm.search(regex, ch, p, e, range);

            if (p != -1 &amp;&amp; p &lt; range) {
                if (p - regex.dMin &lt; s) {
                    // retry_gate:
                    pprev = p;
                    p++;
                    continue retry;
                }

                if (regex.subAnchor != 0) {
                    switch (regex.subAnchor) {
                    case AnchorType.BEGIN_LINE:
                        if (p != string) {
                            final int prev = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                            if (!EncodingHelper.isNewLine(ch, prev, e)) {
                                // goto retry_gate;
                                pprev = p;
                                p++;
                                continue retry;
                            }
                        }
                        break;

                    case AnchorType.END_LINE:
                        if (p == e) {
                            if (!Config.USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE) {
                                final int prev = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                                if (prev != -1 &amp;&amp; EncodingHelper.isNewLine(ch, prev, e)) {
                                    // goto retry_gate;
                                    pprev = p;
                                    p++;
                                    continue retry;
                                }
                            }
                        } else if (!EncodingHelper.isNewLine(ch, p, e)) {
                            //if () break;
                            // goto retry_gate;
                            pprev = p;
                            p++;
                            continue retry;
                        }
                        break;

                    default:
                        break;
                    } // switch
                }

                if (regex.dMax == 0) {
                    low = p;
                    if (lowPrev != null) { // ??? // remove null checks
                        if (low &gt; s) {
                            lowPrev.value = EncodingHelper.prevCharHead(s, p);
                        } else {
                            lowPrev.value = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, p);
                        }
                    }
                } else {
                    if (regex.dMax != MinMaxLen.INFINITE_DISTANCE) {
                        low = p - regex.dMax;

                        if (low &gt; s) {
                            low = EncodingHelper.rightAdjustCharHeadWithPrev(low, lowPrev);
                            if (lowPrev != null &amp;&amp; lowPrev.value == -1) {
                                lowPrev.value = EncodingHelper.prevCharHead((pprev != -1) ? pprev : s, low);
                            }
                        } else {
                            if (lowPrev != null) {
                                lowPrev.value = EncodingHelper.prevCharHead((pprev != -1) ? pprev : string, low);
                            }
                        }
                    }
                }
                /* no needs to adjust *high, *high is used as range check only */
                high = p - regex.dMin;

                if (Config.DEBUG_SEARCH) {
                    Config.log.println("forward_search_range success: "+
                                        "low: " + (low - string) +
                                        ", high: " + (high - string) +
                                        ", dmin: " + regex.dMin +
                                        ", dmax: " + regex.dMax);
                }

                return true;    /* success */
            }

            return false;   /* fail */
        }
</source>
    </clone>
    <clone nlines="184" distance="9">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="990" startcolumn="9" endline="1173" endcolumn="9">
switch (node.getType()) {
        case NodeType.LIST:
            ConsAltNode lin = (ConsAltNode)node;
            Node prev = null;
            do {
                setupTree(lin.car, state);
                if (prev != null) {
                    nextSetup(prev, lin.car);
                }
                prev = lin.car;
            } while ((lin = lin.cdr) != null);
            break;

        case NodeType.ALT:
            ConsAltNode aln = (ConsAltNode)node;
            do {
                setupTree(aln.car, (state | IN_ALT));
            } while ((aln = aln.cdr) != null);
            break;

        case NodeType.CCLASS:
            break;

        case NodeType.STR:
            if (isIgnoreCase(regex.options) &amp;&amp; !((StringNode)node).isRaw()) {
                node = expandCaseFoldString(node);
            }
            break;

        case NodeType.CTYPE:
        case NodeType.CANY:
            break;

        case NodeType.BREF:
            final BackRefNode br = (BackRefNode)node;
            if (br.backRef &gt; env.numMem) {
                throw new ValueException(ERR_INVALID_BACKREF);
            }
            env.backrefedMem = bsOnAt(env.backrefedMem, br.backRef);
            env.btMemStart = bsOnAt(env.btMemStart, br.backRef);
            ((EncloseNode)env.memNodes[br.backRef]).setMemBackrefed();
            break;

        case NodeType.QTFR:
            final QuantifierNode qn = (QuantifierNode)node;
            Node target = qn.target;

            if ((state &amp; IN_REPEAT) != 0) {
                qn.setInRepeat();
            }

            if (isRepeatInfinite(qn.upper) || qn.lower &gt;= 1) {
                final int d = getMinMatchLength(target);
                if (d == 0) {
                    qn.targetEmptyInfo = TargetInfo.IS_EMPTY;
                    if (Config.USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT) {
                        final int info = quantifiersMemoryInfo(target);
                        if (info &gt; 0) {
                            qn.targetEmptyInfo = info;
                        }
                    } // USE_INFINITE_REPEAT_MONOMANIAC_MEM_STATUS_CHECK
                    // strange stuff here (turned off)
                }
            }

            state |= IN_REPEAT;
            if (qn.lower != qn.upper) {
                state |= IN_VAR_REPEAT;
            }

            target = setupTree(target, state);

            /* expand string */
            if (target.getType() == NodeType.STR) {
                if (!isRepeatInfinite(qn.lower) &amp;&amp; qn.lower == qn.upper &amp;&amp;
                    qn.lower &gt; 1 &amp;&amp; qn.lower &lt;= EXPAND_STRING_MAX_LENGTH) {
                    final StringNode sn = (StringNode)target;
                    final int len = sn.length();

                    if (len * qn.lower &lt;= EXPAND_STRING_MAX_LENGTH) {
                        final StringNode str = qn.convertToString(sn.flag);
                        final int n = qn.lower;
                        for (int i = 0; i &lt; n; i++) {
                            str.cat(sn.chars, sn.p, sn.end);
                        }
                        break; /* break case NT_QTFR: */
                    }

                }
            }
            if (Config.USE_OP_PUSH_OR_JUMP_EXACT) {
                if (qn.greedy &amp;&amp; qn.targetEmptyInfo != 0) {
                    if (target.getType() == NodeType.QTFR) {
                        final QuantifierNode tqn = (QuantifierNode)target;
                        if (tqn.headExact != null) {
                            qn.headExact = tqn.headExact;
                            tqn.headExact = null;
                        }
                    } else {
                        qn.headExact = getHeadValueNode(qn.target, true);
                    }
                }
            } // USE_OP_PUSH_OR_JUMP_EXACT
            break;

        case NodeType.ENCLOSE:
            final EncloseNode en = (EncloseNode)node;
            switch (en.type) {
            case EncloseType.OPTION:
                final int options = regex.options;
                regex.options = en.option;
                setupTree(en.target, state);
                regex.options = options;
                break;

            case EncloseType.MEMORY:
                if ((state &amp; (IN_ALT | IN_NOT | IN_VAR_REPEAT)) != 0) {
                    env.btMemStart = bsOnAt(env.btMemStart, en.regNum);
                    /* SET_ENCLOSE_STATUS(node, NST_MEM_IN_ALT_NOT); */

                }
                setupTree(en.target, state);
                break;

            case EncloseType.STOP_BACKTRACK:
                setupTree(en.target, state);
                if (en.target.getType() == NodeType.QTFR) {
                    final QuantifierNode tqn = (QuantifierNode)en.target;
                    if (isRepeatInfinite(tqn.upper) &amp;&amp; tqn.lower &lt;= 1 &amp;&amp; tqn.greedy) {
                        /* (?&gt;a*), a*+ etc... */
                        if (tqn.target.isSimple()) {
                            en.setStopBtSimpleRepeat();
                        }
                    }
                }
                break;

            default:
                break;

            } // inner switch
            break;

        case NodeType.ANCHOR:
            final AnchorNode an = (AnchorNode)node;
            switch (an.type) {
            case AnchorType.PREC_READ:
                setupTree(an.target, state);
                break;

            case AnchorType.PREC_READ_NOT:
                setupTree(an.target, (state | IN_NOT));
                break;

            case AnchorType.LOOK_BEHIND:
                if (checkTypeTree(an.target, NodeType.ALLOWED_IN_LB, EncloseType.ALLOWED_IN_LB, AnchorType.ALLOWED_IN_LB)) {
                    throw new SyntaxException(ERR_INVALID_LOOK_BEHIND_PATTERN);
                }
                node = setupLookBehind(node);
                if (node.getType() != NodeType.ANCHOR) {
                    continue restart;
                }
                setupTree(((AnchorNode)node).target, state);
                break;

            case AnchorType.LOOK_BEHIND_NOT:
                if (checkTypeTree(an.target, NodeType.ALLOWED_IN_LB, EncloseType.ALLOWED_IN_LB, AnchorType.ALLOWED_IN_LB)) {
                    throw new SyntaxException(ERR_INVALID_LOOK_BEHIND_PATTERN);
                }
                node = setupLookBehind(node);
                if (node.getType() != NodeType.ANCHOR) {
                    continue restart;
                }
                setupTree(((AnchorNode)node).target, (state | IN_NOT));
                break;

            default:
                break;

            } // inner switch
            break;
        default:
            break;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="989" startcolumn="18" endline="1175" endcolumn="9">
while (true) {
        switch (node.getType()) {
        case NodeType.LIST:
            ConsAltNode lin = (ConsAltNode)node;
            Node prev = null;
            do {
                setupTree(lin.car, state);
                if (prev != null) {
                    nextSetup(prev, lin.car);
                }
                prev = lin.car;
            } while ((lin = lin.cdr) != null);
            break;

        case NodeType.ALT:
            ConsAltNode aln = (ConsAltNode)node;
            do {
                setupTree(aln.car, (state | IN_ALT));
            } while ((aln = aln.cdr) != null);
            break;

        case NodeType.CCLASS:
            break;

        case NodeType.STR:
            if (isIgnoreCase(regex.options) &amp;&amp; !((StringNode)node).isRaw()) {
                node = expandCaseFoldString(node);
            }
            break;

        case NodeType.CTYPE:
        case NodeType.CANY:
            break;

        case NodeType.BREF:
            final BackRefNode br = (BackRefNode)node;
            if (br.backRef &gt; env.numMem) {
                throw new ValueException(ERR_INVALID_BACKREF);
            }
            env.backrefedMem = bsOnAt(env.backrefedMem, br.backRef);
            env.btMemStart = bsOnAt(env.btMemStart, br.backRef);
            ((EncloseNode)env.memNodes[br.backRef]).setMemBackrefed();
            break;

        case NodeType.QTFR:
            final QuantifierNode qn = (QuantifierNode)node;
            Node target = qn.target;

            if ((state &amp; IN_REPEAT) != 0) {
                qn.setInRepeat();
            }

            if (isRepeatInfinite(qn.upper) || qn.lower &gt;= 1) {
                final int d = getMinMatchLength(target);
                if (d == 0) {
                    qn.targetEmptyInfo = TargetInfo.IS_EMPTY;
                    if (Config.USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT) {
                        final int info = quantifiersMemoryInfo(target);
                        if (info &gt; 0) {
                            qn.targetEmptyInfo = info;
                        }
                    } // USE_INFINITE_REPEAT_MONOMANIAC_MEM_STATUS_CHECK
                    // strange stuff here (turned off)
                }
            }

            state |= IN_REPEAT;
            if (qn.lower != qn.upper) {
                state |= IN_VAR_REPEAT;
            }

            target = setupTree(target, state);

            /* expand string */
            if (target.getType() == NodeType.STR) {
                if (!isRepeatInfinite(qn.lower) &amp;&amp; qn.lower == qn.upper &amp;&amp;
                    qn.lower &gt; 1 &amp;&amp; qn.lower &lt;= EXPAND_STRING_MAX_LENGTH) {
                    final StringNode sn = (StringNode)target;
                    final int len = sn.length();

                    if (len * qn.lower &lt;= EXPAND_STRING_MAX_LENGTH) {
                        final StringNode str = qn.convertToString(sn.flag);
                        final int n = qn.lower;
                        for (int i = 0; i &lt; n; i++) {
                            str.cat(sn.chars, sn.p, sn.end);
                        }
                        break; /* break case NT_QTFR: */
                    }

                }
            }
            if (Config.USE_OP_PUSH_OR_JUMP_EXACT) {
                if (qn.greedy &amp;&amp; qn.targetEmptyInfo != 0) {
                    if (target.getType() == NodeType.QTFR) {
                        final QuantifierNode tqn = (QuantifierNode)target;
                        if (tqn.headExact != null) {
                            qn.headExact = tqn.headExact;
                            tqn.headExact = null;
                        }
                    } else {
                        qn.headExact = getHeadValueNode(qn.target, true);
                    }
                }
            } // USE_OP_PUSH_OR_JUMP_EXACT
            break;

        case NodeType.ENCLOSE:
            final EncloseNode en = (EncloseNode)node;
            switch (en.type) {
            case EncloseType.OPTION:
                final int options = regex.options;
                regex.options = en.option;
                setupTree(en.target, state);
                regex.options = options;
                break;

            case EncloseType.MEMORY:
                if ((state &amp; (IN_ALT | IN_NOT | IN_VAR_REPEAT)) != 0) {
                    env.btMemStart = bsOnAt(env.btMemStart, en.regNum);
                    /* SET_ENCLOSE_STATUS(node, NST_MEM_IN_ALT_NOT); */

                }
                setupTree(en.target, state);
                break;

            case EncloseType.STOP_BACKTRACK:
                setupTree(en.target, state);
                if (en.target.getType() == NodeType.QTFR) {
                    final QuantifierNode tqn = (QuantifierNode)en.target;
                    if (isRepeatInfinite(tqn.upper) &amp;&amp; tqn.lower &lt;= 1 &amp;&amp; tqn.greedy) {
                        /* (?&gt;a*), a*+ etc... */
                        if (tqn.target.isSimple()) {
                            en.setStopBtSimpleRepeat();
                        }
                    }
                }
                break;

            default:
                break;

            } // inner switch
            break;

        case NodeType.ANCHOR:
            final AnchorNode an = (AnchorNode)node;
            switch (an.type) {
            case AnchorType.PREC_READ:
                setupTree(an.target, state);
                break;

            case AnchorType.PREC_READ_NOT:
                setupTree(an.target, (state | IN_NOT));
                break;

            case AnchorType.LOOK_BEHIND:
                if (checkTypeTree(an.target, NodeType.ALLOWED_IN_LB, EncloseType.ALLOWED_IN_LB, AnchorType.ALLOWED_IN_LB)) {
                    throw new SyntaxException(ERR_INVALID_LOOK_BEHIND_PATTERN);
                }
                node = setupLookBehind(node);
                if (node.getType() != NodeType.ANCHOR) {
                    continue restart;
                }
                setupTree(((AnchorNode)node).target, state);
                break;

            case AnchorType.LOOK_BEHIND_NOT:
                if (checkTypeTree(an.target, NodeType.ALLOWED_IN_LB, EncloseType.ALLOWED_IN_LB, AnchorType.ALLOWED_IN_LB)) {
                    throw new SyntaxException(ERR_INVALID_LOOK_BEHIND_PATTERN);
                }
                node = setupLookBehind(node);
                if (node.getType() != NodeType.ANCHOR) {
                    continue restart;
                }
                setupTree(((AnchorNode)node).target, (state | IN_NOT));
                break;

            default:
                break;

            } // inner switch
            break;
        default:
            break;
        } // switch
        return node;
        }
</source>
    </clone>
    <clone nlines="187" distance="2">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="989" startcolumn="18" endline="1175" endcolumn="9">
while (true) {
        switch (node.getType()) {
        case NodeType.LIST:
            ConsAltNode lin = (ConsAltNode)node;
            Node prev = null;
            do {
                setupTree(lin.car, state);
                if (prev != null) {
                    nextSetup(prev, lin.car);
                }
                prev = lin.car;
            } while ((lin = lin.cdr) != null);
            break;

        case NodeType.ALT:
            ConsAltNode aln = (ConsAltNode)node;
            do {
                setupTree(aln.car, (state | IN_ALT));
            } while ((aln = aln.cdr) != null);
            break;

        case NodeType.CCLASS:
            break;

        case NodeType.STR:
            if (isIgnoreCase(regex.options) &amp;&amp; !((StringNode)node).isRaw()) {
                node = expandCaseFoldString(node);
            }
            break;

        case NodeType.CTYPE:
        case NodeType.CANY:
            break;

        case NodeType.BREF:
            final BackRefNode br = (BackRefNode)node;
            if (br.backRef &gt; env.numMem) {
                throw new ValueException(ERR_INVALID_BACKREF);
            }
            env.backrefedMem = bsOnAt(env.backrefedMem, br.backRef);
            env.btMemStart = bsOnAt(env.btMemStart, br.backRef);
            ((EncloseNode)env.memNodes[br.backRef]).setMemBackrefed();
            break;

        case NodeType.QTFR:
            final QuantifierNode qn = (QuantifierNode)node;
            Node target = qn.target;

            if ((state &amp; IN_REPEAT) != 0) {
                qn.setInRepeat();
            }

            if (isRepeatInfinite(qn.upper) || qn.lower &gt;= 1) {
                final int d = getMinMatchLength(target);
                if (d == 0) {
                    qn.targetEmptyInfo = TargetInfo.IS_EMPTY;
                    if (Config.USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT) {
                        final int info = quantifiersMemoryInfo(target);
                        if (info &gt; 0) {
                            qn.targetEmptyInfo = info;
                        }
                    } // USE_INFINITE_REPEAT_MONOMANIAC_MEM_STATUS_CHECK
                    // strange stuff here (turned off)
                }
            }

            state |= IN_REPEAT;
            if (qn.lower != qn.upper) {
                state |= IN_VAR_REPEAT;
            }

            target = setupTree(target, state);

            /* expand string */
            if (target.getType() == NodeType.STR) {
                if (!isRepeatInfinite(qn.lower) &amp;&amp; qn.lower == qn.upper &amp;&amp;
                    qn.lower &gt; 1 &amp;&amp; qn.lower &lt;= EXPAND_STRING_MAX_LENGTH) {
                    final StringNode sn = (StringNode)target;
                    final int len = sn.length();

                    if (len * qn.lower &lt;= EXPAND_STRING_MAX_LENGTH) {
                        final StringNode str = qn.convertToString(sn.flag);
                        final int n = qn.lower;
                        for (int i = 0; i &lt; n; i++) {
                            str.cat(sn.chars, sn.p, sn.end);
                        }
                        break; /* break case NT_QTFR: */
                    }

                }
            }
            if (Config.USE_OP_PUSH_OR_JUMP_EXACT) {
                if (qn.greedy &amp;&amp; qn.targetEmptyInfo != 0) {
                    if (target.getType() == NodeType.QTFR) {
                        final QuantifierNode tqn = (QuantifierNode)target;
                        if (tqn.headExact != null) {
                            qn.headExact = tqn.headExact;
                            tqn.headExact = null;
                        }
                    } else {
                        qn.headExact = getHeadValueNode(qn.target, true);
                    }
                }
            } // USE_OP_PUSH_OR_JUMP_EXACT
            break;

        case NodeType.ENCLOSE:
            final EncloseNode en = (EncloseNode)node;
            switch (en.type) {
            case EncloseType.OPTION:
                final int options = regex.options;
                regex.options = en.option;
                setupTree(en.target, state);
                regex.options = options;
                break;

            case EncloseType.MEMORY:
                if ((state &amp; (IN_ALT | IN_NOT | IN_VAR_REPEAT)) != 0) {
                    env.btMemStart = bsOnAt(env.btMemStart, en.regNum);
                    /* SET_ENCLOSE_STATUS(node, NST_MEM_IN_ALT_NOT); */

                }
                setupTree(en.target, state);
                break;

            case EncloseType.STOP_BACKTRACK:
                setupTree(en.target, state);
                if (en.target.getType() == NodeType.QTFR) {
                    final QuantifierNode tqn = (QuantifierNode)en.target;
                    if (isRepeatInfinite(tqn.upper) &amp;&amp; tqn.lower &lt;= 1 &amp;&amp; tqn.greedy) {
                        /* (?&gt;a*), a*+ etc... */
                        if (tqn.target.isSimple()) {
                            en.setStopBtSimpleRepeat();
                        }
                    }
                }
                break;

            default:
                break;

            } // inner switch
            break;

        case NodeType.ANCHOR:
            final AnchorNode an = (AnchorNode)node;
            switch (an.type) {
            case AnchorType.PREC_READ:
                setupTree(an.target, state);
                break;

            case AnchorType.PREC_READ_NOT:
                setupTree(an.target, (state | IN_NOT));
                break;

            case AnchorType.LOOK_BEHIND:
                if (checkTypeTree(an.target, NodeType.ALLOWED_IN_LB, EncloseType.ALLOWED_IN_LB, AnchorType.ALLOWED_IN_LB)) {
                    throw new SyntaxException(ERR_INVALID_LOOK_BEHIND_PATTERN);
                }
                node = setupLookBehind(node);
                if (node.getType() != NodeType.ANCHOR) {
                    continue restart;
                }
                setupTree(((AnchorNode)node).target, state);
                break;

            case AnchorType.LOOK_BEHIND_NOT:
                if (checkTypeTree(an.target, NodeType.ALLOWED_IN_LB, EncloseType.ALLOWED_IN_LB, AnchorType.ALLOWED_IN_LB)) {
                    throw new SyntaxException(ERR_INVALID_LOOK_BEHIND_PATTERN);
                }
                node = setupLookBehind(node);
                if (node.getType() != NodeType.ANCHOR) {
                    continue restart;
                }
                setupTree(((AnchorNode)node).target, (state | IN_NOT));
                break;

            default:
                break;

            } // inner switch
            break;
        default:
            break;
        } // switch
        return node;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Analyser.java" startline="989" startcolumn="9" endline="1175" endcolumn="9">
restart: while (true) {
        switch (node.getType()) {
        case NodeType.LIST:
            ConsAltNode lin = (ConsAltNode)node;
            Node prev = null;
            do {
                setupTree(lin.car, state);
                if (prev != null) {
                    nextSetup(prev, lin.car);
                }
                prev = lin.car;
            } while ((lin = lin.cdr) != null);
            break;

        case NodeType.ALT:
            ConsAltNode aln = (ConsAltNode)node;
            do {
                setupTree(aln.car, (state | IN_ALT));
            } while ((aln = aln.cdr) != null);
            break;

        case NodeType.CCLASS:
            break;

        case NodeType.STR:
            if (isIgnoreCase(regex.options) &amp;&amp; !((StringNode)node).isRaw()) {
                node = expandCaseFoldString(node);
            }
            break;

        case NodeType.CTYPE:
        case NodeType.CANY:
            break;

        case NodeType.BREF:
            final BackRefNode br = (BackRefNode)node;
            if (br.backRef &gt; env.numMem) {
                throw new ValueException(ERR_INVALID_BACKREF);
            }
            env.backrefedMem = bsOnAt(env.backrefedMem, br.backRef);
            env.btMemStart = bsOnAt(env.btMemStart, br.backRef);
            ((EncloseNode)env.memNodes[br.backRef]).setMemBackrefed();
            break;

        case NodeType.QTFR:
            final QuantifierNode qn = (QuantifierNode)node;
            Node target = qn.target;

            if ((state &amp; IN_REPEAT) != 0) {
                qn.setInRepeat();
            }

            if (isRepeatInfinite(qn.upper) || qn.lower &gt;= 1) {
                final int d = getMinMatchLength(target);
                if (d == 0) {
                    qn.targetEmptyInfo = TargetInfo.IS_EMPTY;
                    if (Config.USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT) {
                        final int info = quantifiersMemoryInfo(target);
                        if (info &gt; 0) {
                            qn.targetEmptyInfo = info;
                        }
                    } // USE_INFINITE_REPEAT_MONOMANIAC_MEM_STATUS_CHECK
                    // strange stuff here (turned off)
                }
            }

            state |= IN_REPEAT;
            if (qn.lower != qn.upper) {
                state |= IN_VAR_REPEAT;
            }

            target = setupTree(target, state);

            /* expand string */
            if (target.getType() == NodeType.STR) {
                if (!isRepeatInfinite(qn.lower) &amp;&amp; qn.lower == qn.upper &amp;&amp;
                    qn.lower &gt; 1 &amp;&amp; qn.lower &lt;= EXPAND_STRING_MAX_LENGTH) {
                    final StringNode sn = (StringNode)target;
                    final int len = sn.length();

                    if (len * qn.lower &lt;= EXPAND_STRING_MAX_LENGTH) {
                        final StringNode str = qn.convertToString(sn.flag);
                        final int n = qn.lower;
                        for (int i = 0; i &lt; n; i++) {
                            str.cat(sn.chars, sn.p, sn.end);
                        }
                        break; /* break case NT_QTFR: */
                    }

                }
            }
            if (Config.USE_OP_PUSH_OR_JUMP_EXACT) {
                if (qn.greedy &amp;&amp; qn.targetEmptyInfo != 0) {
                    if (target.getType() == NodeType.QTFR) {
                        final QuantifierNode tqn = (QuantifierNode)target;
                        if (tqn.headExact != null) {
                            qn.headExact = tqn.headExact;
                            tqn.headExact = null;
                        }
                    } else {
                        qn.headExact = getHeadValueNode(qn.target, true);
                    }
                }
            } // USE_OP_PUSH_OR_JUMP_EXACT
            break;

        case NodeType.ENCLOSE:
            final EncloseNode en = (EncloseNode)node;
            switch (en.type) {
            case EncloseType.OPTION:
                final int options = regex.options;
                regex.options = en.option;
                setupTree(en.target, state);
                regex.options = options;
                break;

            case EncloseType.MEMORY:
                if ((state &amp; (IN_ALT | IN_NOT | IN_VAR_REPEAT)) != 0) {
                    env.btMemStart = bsOnAt(env.btMemStart, en.regNum);
                    /* SET_ENCLOSE_STATUS(node, NST_MEM_IN_ALT_NOT); */

                }
                setupTree(en.target, state);
                break;

            case EncloseType.STOP_BACKTRACK:
                setupTree(en.target, state);
                if (en.target.getType() == NodeType.QTFR) {
                    final QuantifierNode tqn = (QuantifierNode)en.target;
                    if (isRepeatInfinite(tqn.upper) &amp;&amp; tqn.lower &lt;= 1 &amp;&amp; tqn.greedy) {
                        /* (?&gt;a*), a*+ etc... */
                        if (tqn.target.isSimple()) {
                            en.setStopBtSimpleRepeat();
                        }
                    }
                }
                break;

            default:
                break;

            } // inner switch
            break;

        case NodeType.ANCHOR:
            final AnchorNode an = (AnchorNode)node;
            switch (an.type) {
            case AnchorType.PREC_READ:
                setupTree(an.target, state);
                break;

            case AnchorType.PREC_READ_NOT:
                setupTree(an.target, (state | IN_NOT));
                break;

            case AnchorType.LOOK_BEHIND:
                if (checkTypeTree(an.target, NodeType.ALLOWED_IN_LB, EncloseType.ALLOWED_IN_LB, AnchorType.ALLOWED_IN_LB)) {
                    throw new SyntaxException(ERR_INVALID_LOOK_BEHIND_PATTERN);
                }
                node = setupLookBehind(node);
                if (node.getType() != NodeType.ANCHOR) {
                    continue restart;
                }
                setupTree(((AnchorNode)node).target, state);
                break;

            case AnchorType.LOOK_BEHIND_NOT:
                if (checkTypeTree(an.target, NodeType.ALLOWED_IN_LB, EncloseType.ALLOWED_IN_LB, AnchorType.ALLOWED_IN_LB)) {
                    throw new SyntaxException(ERR_INVALID_LOOK_BEHIND_PATTERN);
                }
                node = setupLookBehind(node);
                if (node.getType() != NodeType.ANCHOR) {
                    continue restart;
                }
                setupTree(((AnchorNode)node).target, (state | IN_NOT));
                break;

            default:
                break;

            } // inner switch
            break;
        default:
            break;
        } // switch
        return node;
        }
</source>
    </clone>
    <clone nlines="311" distance="2">
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="553" startcolumn="9" endline="863" endcolumn="9">
while(true) {
            if (!left()) {
                token.type = TokenType.EOT;
                return token.type;
            }

            token.type = TokenType.STRING;
            token.backP = p;

            fetch();

            if (c == syntax.metaCharTable.esc &amp;&amp; !syntax.op2IneffectiveEscape()) { // IS_MC_ESC_CODE(code, syn)
                if (!left()) {
                    throw new SyntaxException(ERR_END_PATTERN_AT_ESCAPE);
                }

                token.backP = p;
                fetch();

                token.setC(c);
                token.escaped = true;
                switch(c) {

                case '*':
                    if (syntax.opEscAsteriskZeroInf()) {
                        fetchTokenFor_repeat(0, QuantifierNode.REPEAT_INFINITE);
                    }
                    break;
                case '+':
                    if (syntax.opEscPlusOneInf()) {
                        fetchTokenFor_repeat(1, QuantifierNode.REPEAT_INFINITE);
                    }
                    break;
                case '?':
                    if (syntax.opEscQMarkZeroOne()) {
                        fetchTokenFor_repeat(0, 1);
                    }
                    break;
                case '{':
                    if (syntax.opEscBraceInterval()) {
                        fetchTokenFor_openBrace();
                    }
                    break;
                case '|':
                    if (syntax.opEscVBarAlt()) {
                        token.type = TokenType.ALT;
                    }
                    break;
                case '(':
                    if (syntax.opEscLParenSubexp()) {
                        token.type = TokenType.SUBEXP_OPEN;
                    }
                    break;
                case ')':
                    if (syntax.opEscLParenSubexp()) {
                        token.type = TokenType.SUBEXP_CLOSE;
                    }
                    break;
                case 'w':
                    if (syntax.opEscWWord()) {
                        fetchTokenInCCFor_charType(false, Config.NON_UNICODE_SDW ? CharacterType.W : CharacterType.WORD);
                    }
                    break;
                case 'W':
                    if (syntax.opEscWWord()) {
                        fetchTokenInCCFor_charType(true, Config.NON_UNICODE_SDW ? CharacterType.W : CharacterType.WORD);
                    }
                    break;
                case 'b':
                    if (syntax.opEscBWordBound()) {
                        fetchTokenFor_anchor(AnchorType.WORD_BOUND);
                    }
                    break;
                case 'B':
                    if (syntax.opEscBWordBound()) {
                        fetchTokenFor_anchor(AnchorType.NOT_WORD_BOUND);
                    }
                    break;
                case '&lt;':
                    if (Config.USE_WORD_BEGIN_END &amp;&amp; syntax.opEscLtGtWordBeginEnd()) {
                        fetchTokenFor_anchor(AnchorType.WORD_BEGIN);
                    }
                    break;
                case '&gt;':
                    if (Config.USE_WORD_BEGIN_END &amp;&amp; syntax.opEscLtGtWordBeginEnd()) {
                        fetchTokenFor_anchor(AnchorType.WORD_END);
                    }
                    break;
                case 's':
                    if (syntax.opEscSWhiteSpace()) {
                        fetchTokenInCCFor_charType(false, Config.NON_UNICODE_SDW ? CharacterType.S : CharacterType.SPACE);
                    }
                    break;
                case 'S':
                    if (syntax.opEscSWhiteSpace()) {
                        fetchTokenInCCFor_charType(true, Config.NON_UNICODE_SDW ? CharacterType.S : CharacterType.SPACE);
                    }
                    break;
                case 'd':
                    if (syntax.opEscDDigit()) {
                        fetchTokenInCCFor_charType(false, Config.NON_UNICODE_SDW ? CharacterType.D : CharacterType.DIGIT);
                    }
                    break;
                case 'D':
                    if (syntax.opEscDDigit()) {
                        fetchTokenInCCFor_charType(true, Config.NON_UNICODE_SDW ? CharacterType.D : CharacterType.DIGIT);
                    }
                    break;
                case 'h':
                    if (syntax.op2EscHXDigit()) {
                        fetchTokenInCCFor_charType(false, CharacterType.XDIGIT);
                    }
                    break;
                case 'H':
                    if (syntax.op2EscHXDigit()) {
                        fetchTokenInCCFor_charType(true, CharacterType.XDIGIT);
                    }
                    break;
                case 'A':
                    if (syntax.opEscAZBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.BEGIN_BUF);
                    }
                    break;
                case 'Z':
                    if (syntax.opEscAZBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.SEMI_END_BUF);
                    }
                    break;
                case 'z':
                    if (syntax.opEscAZBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.END_BUF);
                    }
                    break;
                case 'G':
                    if (syntax.opEscCapitalGBeginAnchor()) {
                        fetchTokenFor_anchor(AnchorType.BEGIN_POSITION);
                    }
                    break;
                case '`':
                    if (syntax.op2EscGnuBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.BEGIN_BUF);
                    }
                    break;
                case '\'':
                    if (syntax.op2EscGnuBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.END_BUF);
                    }
                    break;
                case 'x':
                    fetchTokenFor_xBrace();
                    break;
                case 'u':
                    fetchTokenFor_uHex();
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    fetchTokenFor_digit();
                    break;
                case '0':
                    fetchTokenFor_zero();
                    break;

                default:
                    unfetch();
                    final int num = fetchEscapedValue();

                    /* set_raw: */
                    if (token.getC() != num) {
                        token.type = TokenType.CODE_POINT;
                        token.setCode(num);
                    } else { /* string */
                        p = token.backP + 1;
                    }
                    break;

                } // switch (c)

            } else {
                token.setC(c);
                token.escaped = false;

                if (Config.USE_VARIABLE_META_CHARS &amp;&amp; (c != MetaChar.INEFFECTIVE_META_CHAR &amp;&amp; syntax.opVariableMetaCharacters())) {
                    fetchTokenFor_metaChars();
                    break;
                }

                {
                    switch(c) {
                    case '.':
                        if (syntax.opDotAnyChar()) {
                            token.type = TokenType.ANYCHAR;
                        }
                        break;
                    case '*':
                        if (syntax.opAsteriskZeroInf()) {
                            fetchTokenFor_repeat(0, QuantifierNode.REPEAT_INFINITE);
                        }
                        break;
                    case '+':
                        if (syntax.opPlusOneInf()) {
                            fetchTokenFor_repeat(1, QuantifierNode.REPEAT_INFINITE);
                        }
                        break;
                    case '?':
                        if (syntax.opQMarkZeroOne()) {
                            fetchTokenFor_repeat(0, 1);
                        }
                        break;
                    case '{':
                        if (syntax.opBraceInterval()) {
                            fetchTokenFor_openBrace();
                        }
                        break;
                    case '|':
                        if (syntax.opVBarAlt()) {
                            token.type = TokenType.ALT;
                        }
                        break;

                    case '(':
                        if (peekIs('?') &amp;&amp; syntax.op2QMarkGroupEffect()) {
                            inc();
                            if (peekIs('#')) {
                                fetch();
                                while (true) {
                                    if (!left()) {
                                        throw new SyntaxException(ERR_END_PATTERN_IN_GROUP);
                                    }
                                    fetch();
                                    if (c == syntax.metaCharTable.esc) {
                                        if (left()) {
                                            fetch();
                                        }
                                    } else {
                                        if (c == ')') {
                                            break;
                                        }
                                    }
                                }
                                continue start; // goto start
                            }
                            unfetch();
                        }

                        if (syntax.opLParenSubexp()) {
                            token.type = TokenType.SUBEXP_OPEN;
                        }
                        break;
                    case ')':
                        if (syntax.opLParenSubexp()) {
                            token.type = TokenType.SUBEXP_CLOSE;
                        }
                        break;
                    case '^':
                        if (syntax.opLineAnchor()) {
                            fetchTokenFor_anchor(isSingleline(env.option) ? AnchorType.BEGIN_BUF : AnchorType.BEGIN_LINE);
                        }
                        break;
                    case '$':
                        if (syntax.opLineAnchor()) {
                            fetchTokenFor_anchor(isSingleline(env.option) ? AnchorType.END_BUF : AnchorType.END_LINE);
                        }
                        break;
                    case '[':
                        if (syntax.opBracketCC()) {
                            token.type = TokenType.CC_CC_OPEN;
                        }
                        break;
                    case ']':
                        //if (*src &gt; env-&gt;pattern)   /* /].../ is allowed. */
                        //CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )"]");
                        break;
                    case '#':
                        if (Option.isExtend(env.option)) {
                            while (left()) {
                                fetch();
                                if (EncodingHelper.isNewLine(c)) {
                                    break;
                                }
                            }
                            continue start; // goto start
                        }
                        break;

                    case ' ':
                    case '\t':
                    case '\n':
                    case '\r':
                    case '\f':
                        if (Option.isExtend(env.option))
                         {
                            continue start; // goto start
                        }
                        break;

                    default: // string
                        break;

                    } // switch
                }
            }

            break;
        }
</source>
        <source file="jdk/nashorn/internal/runtime/regexp/joni/Lexer.java" startline="552" startcolumn="9" endline="863" endcolumn="9">
start:
        while(true) {
            if (!left()) {
                token.type = TokenType.EOT;
                return token.type;
            }

            token.type = TokenType.STRING;
            token.backP = p;

            fetch();

            if (c == syntax.metaCharTable.esc &amp;&amp; !syntax.op2IneffectiveEscape()) { // IS_MC_ESC_CODE(code, syn)
                if (!left()) {
                    throw new SyntaxException(ERR_END_PATTERN_AT_ESCAPE);
                }

                token.backP = p;
                fetch();

                token.setC(c);
                token.escaped = true;
                switch(c) {

                case '*':
                    if (syntax.opEscAsteriskZeroInf()) {
                        fetchTokenFor_repeat(0, QuantifierNode.REPEAT_INFINITE);
                    }
                    break;
                case '+':
                    if (syntax.opEscPlusOneInf()) {
                        fetchTokenFor_repeat(1, QuantifierNode.REPEAT_INFINITE);
                    }
                    break;
                case '?':
                    if (syntax.opEscQMarkZeroOne()) {
                        fetchTokenFor_repeat(0, 1);
                    }
                    break;
                case '{':
                    if (syntax.opEscBraceInterval()) {
                        fetchTokenFor_openBrace();
                    }
                    break;
                case '|':
                    if (syntax.opEscVBarAlt()) {
                        token.type = TokenType.ALT;
                    }
                    break;
                case '(':
                    if (syntax.opEscLParenSubexp()) {
                        token.type = TokenType.SUBEXP_OPEN;
                    }
                    break;
                case ')':
                    if (syntax.opEscLParenSubexp()) {
                        token.type = TokenType.SUBEXP_CLOSE;
                    }
                    break;
                case 'w':
                    if (syntax.opEscWWord()) {
                        fetchTokenInCCFor_charType(false, Config.NON_UNICODE_SDW ? CharacterType.W : CharacterType.WORD);
                    }
                    break;
                case 'W':
                    if (syntax.opEscWWord()) {
                        fetchTokenInCCFor_charType(true, Config.NON_UNICODE_SDW ? CharacterType.W : CharacterType.WORD);
                    }
                    break;
                case 'b':
                    if (syntax.opEscBWordBound()) {
                        fetchTokenFor_anchor(AnchorType.WORD_BOUND);
                    }
                    break;
                case 'B':
                    if (syntax.opEscBWordBound()) {
                        fetchTokenFor_anchor(AnchorType.NOT_WORD_BOUND);
                    }
                    break;
                case '&lt;':
                    if (Config.USE_WORD_BEGIN_END &amp;&amp; syntax.opEscLtGtWordBeginEnd()) {
                        fetchTokenFor_anchor(AnchorType.WORD_BEGIN);
                    }
                    break;
                case '&gt;':
                    if (Config.USE_WORD_BEGIN_END &amp;&amp; syntax.opEscLtGtWordBeginEnd()) {
                        fetchTokenFor_anchor(AnchorType.WORD_END);
                    }
                    break;
                case 's':
                    if (syntax.opEscSWhiteSpace()) {
                        fetchTokenInCCFor_charType(false, Config.NON_UNICODE_SDW ? CharacterType.S : CharacterType.SPACE);
                    }
                    break;
                case 'S':
                    if (syntax.opEscSWhiteSpace()) {
                        fetchTokenInCCFor_charType(true, Config.NON_UNICODE_SDW ? CharacterType.S : CharacterType.SPACE);
                    }
                    break;
                case 'd':
                    if (syntax.opEscDDigit()) {
                        fetchTokenInCCFor_charType(false, Config.NON_UNICODE_SDW ? CharacterType.D : CharacterType.DIGIT);
                    }
                    break;
                case 'D':
                    if (syntax.opEscDDigit()) {
                        fetchTokenInCCFor_charType(true, Config.NON_UNICODE_SDW ? CharacterType.D : CharacterType.DIGIT);
                    }
                    break;
                case 'h':
                    if (syntax.op2EscHXDigit()) {
                        fetchTokenInCCFor_charType(false, CharacterType.XDIGIT);
                    }
                    break;
                case 'H':
                    if (syntax.op2EscHXDigit()) {
                        fetchTokenInCCFor_charType(true, CharacterType.XDIGIT);
                    }
                    break;
                case 'A':
                    if (syntax.opEscAZBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.BEGIN_BUF);
                    }
                    break;
                case 'Z':
                    if (syntax.opEscAZBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.SEMI_END_BUF);
                    }
                    break;
                case 'z':
                    if (syntax.opEscAZBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.END_BUF);
                    }
                    break;
                case 'G':
                    if (syntax.opEscCapitalGBeginAnchor()) {
                        fetchTokenFor_anchor(AnchorType.BEGIN_POSITION);
                    }
                    break;
                case '`':
                    if (syntax.op2EscGnuBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.BEGIN_BUF);
                    }
                    break;
                case '\'':
                    if (syntax.op2EscGnuBufAnchor()) {
                        fetchTokenFor_anchor(AnchorType.END_BUF);
                    }
                    break;
                case 'x':
                    fetchTokenFor_xBrace();
                    break;
                case 'u':
                    fetchTokenFor_uHex();
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    fetchTokenFor_digit();
                    break;
                case '0':
                    fetchTokenFor_zero();
                    break;

                default:
                    unfetch();
                    final int num = fetchEscapedValue();

                    /* set_raw: */
                    if (token.getC() != num) {
                        token.type = TokenType.CODE_POINT;
                        token.setCode(num);
                    } else { /* string */
                        p = token.backP + 1;
                    }
                    break;

                } // switch (c)

            } else {
                token.setC(c);
                token.escaped = false;

                if (Config.USE_VARIABLE_META_CHARS &amp;&amp; (c != MetaChar.INEFFECTIVE_META_CHAR &amp;&amp; syntax.opVariableMetaCharacters())) {
                    fetchTokenFor_metaChars();
                    break;
                }

                {
                    switch(c) {
                    case '.':
                        if (syntax.opDotAnyChar()) {
                            token.type = TokenType.ANYCHAR;
                        }
                        break;
                    case '*':
                        if (syntax.opAsteriskZeroInf()) {
                            fetchTokenFor_repeat(0, QuantifierNode.REPEAT_INFINITE);
                        }
                        break;
                    case '+':
                        if (syntax.opPlusOneInf()) {
                            fetchTokenFor_repeat(1, QuantifierNode.REPEAT_INFINITE);
                        }
                        break;
                    case '?':
                        if (syntax.opQMarkZeroOne()) {
                            fetchTokenFor_repeat(0, 1);
                        }
                        break;
                    case '{':
                        if (syntax.opBraceInterval()) {
                            fetchTokenFor_openBrace();
                        }
                        break;
                    case '|':
                        if (syntax.opVBarAlt()) {
                            token.type = TokenType.ALT;
                        }
                        break;

                    case '(':
                        if (peekIs('?') &amp;&amp; syntax.op2QMarkGroupEffect()) {
                            inc();
                            if (peekIs('#')) {
                                fetch();
                                while (true) {
                                    if (!left()) {
                                        throw new SyntaxException(ERR_END_PATTERN_IN_GROUP);
                                    }
                                    fetch();
                                    if (c == syntax.metaCharTable.esc) {
                                        if (left()) {
                                            fetch();
                                        }
                                    } else {
                                        if (c == ')') {
                                            break;
                                        }
                                    }
                                }
                                continue start; // goto start
                            }
                            unfetch();
                        }

                        if (syntax.opLParenSubexp()) {
                            token.type = TokenType.SUBEXP_OPEN;
                        }
                        break;
                    case ')':
                        if (syntax.opLParenSubexp()) {
                            token.type = TokenType.SUBEXP_CLOSE;
                        }
                        break;
                    case '^':
                        if (syntax.opLineAnchor()) {
                            fetchTokenFor_anchor(isSingleline(env.option) ? AnchorType.BEGIN_BUF : AnchorType.BEGIN_LINE);
                        }
                        break;
                    case '$':
                        if (syntax.opLineAnchor()) {
                            fetchTokenFor_anchor(isSingleline(env.option) ? AnchorType.END_BUF : AnchorType.END_LINE);
                        }
                        break;
                    case '[':
                        if (syntax.opBracketCC()) {
                            token.type = TokenType.CC_CC_OPEN;
                        }
                        break;
                    case ']':
                        //if (*src &gt; env-&gt;pattern)   /* /].../ is allowed. */
                        //CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )"]");
                        break;
                    case '#':
                        if (Option.isExtend(env.option)) {
                            while (left()) {
                                fetch();
                                if (EncodingHelper.isNewLine(c)) {
                                    break;
                                }
                            }
                            continue start; // goto start
                        }
                        break;

                    case ' ':
                    case '\t':
                    case '\n':
                    case '\r':
                    case '\f':
                        if (Option.isExtend(env.option))
                         {
                            continue start; // goto start
                        }
                        break;

                    default: // string
                        break;

                    } // switch
                }
            }

            break;
        }
</source>
    </clone>
</clones>
