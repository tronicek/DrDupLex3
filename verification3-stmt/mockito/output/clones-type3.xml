<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<clones>
    <clone nlines="10" distance="5">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="85" endline="94">
return new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="537" endline="548">
return new MockitoException(join(
                "No argument value was captured!",
                "You might have forgotten to use argument.capture() in verify()...",
                "...or you used capture() in stubbing but stubbed method was not called.",
                "Be aware that it is recommended to use capture() only with verify()",
                "",
                "Examples of correct argument capturing:",
                "    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);",
                "    verify(mock).doSomething(argument.capture());",
                "    assertEquals(\"John\", argument.getValue().getName());",
                ""
        ));
</source>
    </clone>
    <clone nlines="10" distance="7">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="85" endline="94">
return new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="113" endline="124">
return new UnfinishedVerificationException(join(
                "Missing method call for verify(mock) here:",
                location,
                "",
                "Example of correct verification:",
                "    verify(mock).doSomething()",
                "",
                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
                "Those methods *cannot* be stubbed/verified.",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="10" distance="9">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="85" endline="94">
return new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="98" endline="109">
return new MissingMethodInvocationException(join(
                "when() requires an argument which has to be 'a method call on a mock'.",
                "For example:",
                "    when(mock.getArticles()).thenReturn(articles);",
                "",
                "Also, this error might show up because:",
                "1. you stub either of: final/private/equals()/hashCode() methods.",
                "   Those methods *cannot* be stubbed/verified.",
                "   " + MockitoLimitations.NON_PUBLIC_PARENT,
                "2. inside when() you don't call method on mock but on some other object.",
                ""
        ));
</source>
    </clone>
    <clone nlines="10" distance="11">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="85" endline="94">
return new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
    </clone>
    <clone nlines="10" distance="14">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="85" endline="94">
return new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
    </clone>
    <clone nlines="10" distance="14">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="85" endline="94">
return new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
    </clone>
    <clone nlines="10" distance="18">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="85" endline="94">
return new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="342" endline="351">
return new VerificationInOrderFailure(join(
                "Verification in order failure",
                "Wanted but not invoked:",
                wanted.toString(),
                new LocationImpl(),
                "Wanted anywhere AFTER following interaction:",
                previous.toString(),
                previous.getLocation(),
                ""
        ));
</source>
    </clone>
    <clone nlines="10" distance="14">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="85" endline="94">
return new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="10" distance="17">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="85" endline="94">
return new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="4">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="537" endline="548">
return new MockitoException(join(
                "No argument value was captured!",
                "You might have forgotten to use argument.capture() in verify()...",
                "...or you used capture() in stubbing but stubbed method was not called.",
                "Be aware that it is recommended to use capture() only with verify()",
                "",
                "Examples of correct argument capturing:",
                "    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);",
                "    verify(mock).doSomething(argument.capture());",
                "    assertEquals(\"John\", argument.getValue().getName());",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="113" endline="124">
return new UnfinishedVerificationException(join(
                "Missing method call for verify(mock) here:",
                location,
                "",
                "Example of correct verification:",
                "    verify(mock).doSomething()",
                "",
                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
                "Those methods *cannot* be stubbed/verified.",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="4">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="537" endline="548">
return new MockitoException(join(
                "No argument value was captured!",
                "You might have forgotten to use argument.capture() in verify()...",
                "...or you used capture() in stubbing but stubbed method was not called.",
                "Be aware that it is recommended to use capture() only with verify()",
                "",
                "Examples of correct argument capturing:",
                "    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);",
                "    verify(mock).doSomething(argument.capture());",
                "    assertEquals(\"John\", argument.getValue().getName());",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="98" endline="109">
return new MissingMethodInvocationException(join(
                "when() requires an argument which has to be 'a method call on a mock'.",
                "For example:",
                "    when(mock.getArticles()).thenReturn(articles);",
                "",
                "Also, this error might show up because:",
                "1. you stub either of: final/private/equals()/hashCode() methods.",
                "   Those methods *cannot* be stubbed/verified.",
                "   " + MockitoLimitations.NON_PUBLIC_PARENT,
                "2. inside when() you don't call method on mock but on some other object.",
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="6">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="537" endline="548">
return new MockitoException(join(
                "No argument value was captured!",
                "You might have forgotten to use argument.capture() in verify()...",
                "...or you used capture() in stubbing but stubbed method was not called.",
                "Be aware that it is recommended to use capture() only with verify()",
                "",
                "Examples of correct argument capturing:",
                "    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);",
                "    verify(mock).doSomething(argument.capture());",
                "    assertEquals(\"John\", argument.getValue().getName());",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="10">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="537" endline="548">
return new MockitoException(join(
                "No argument value was captured!",
                "You might have forgotten to use argument.capture() in verify()...",
                "...or you used capture() in stubbing but stubbed method was not called.",
                "Be aware that it is recommended to use capture() only with verify()",
                "",
                "Examples of correct argument capturing:",
                "    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);",
                "    verify(mock).doSomething(argument.capture());",
                "    assertEquals(\"John\", argument.getValue().getName());",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="12">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="537" endline="548">
return new MockitoException(join(
                "No argument value was captured!",
                "You might have forgotten to use argument.capture() in verify()...",
                "...or you used capture() in stubbing but stubbed method was not called.",
                "Be aware that it is recommended to use capture() only with verify()",
                "",
                "Examples of correct argument capturing:",
                "    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);",
                "    verify(mock).doSomething(argument.capture());",
                "    assertEquals(\"John\", argument.getValue().getName());",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
    </clone>
    <clone nlines="10" distance="19">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="537" endline="548">
return new MockitoException(join(
                "No argument value was captured!",
                "You might have forgotten to use argument.capture() in verify()...",
                "...or you used capture() in stubbing but stubbed method was not called.",
                "Be aware that it is recommended to use capture() only with verify()",
                "",
                "Examples of correct argument capturing:",
                "    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);",
                "    verify(mock).doSomething(argument.capture());",
                "    assertEquals(\"John\", argument.getValue().getName());",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="342" endline="351">
return new VerificationInOrderFailure(join(
                "Verification in order failure",
                "Wanted but not invoked:",
                wanted.toString(),
                new LocationImpl(),
                "Wanted anywhere AFTER following interaction:",
                previous.toString(),
                previous.getLocation(),
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="11">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="537" endline="548">
return new MockitoException(join(
                "No argument value was captured!",
                "You might have forgotten to use argument.capture() in verify()...",
                "...or you used capture() in stubbing but stubbed method was not called.",
                "Be aware that it is recommended to use capture() only with verify()",
                "",
                "Examples of correct argument capturing:",
                "    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);",
                "    verify(mock).doSomething(argument.capture());",
                "    assertEquals(\"John\", argument.getValue().getName());",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="12">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="537" endline="548">
return new MockitoException(join(
                "No argument value was captured!",
                "You might have forgotten to use argument.capture() in verify()...",
                "...or you used capture() in stubbing but stubbed method was not called.",
                "Be aware that it is recommended to use capture() only with verify()",
                "",
                "Examples of correct argument capturing:",
                "    ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);",
                "    verify(mock).doSomething(argument.capture());",
                "    assertEquals(\"John\", argument.getValue().getName());",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="4">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="113" endline="124">
return new UnfinishedVerificationException(join(
                "Missing method call for verify(mock) here:",
                location,
                "",
                "Example of correct verification:",
                "    verify(mock).doSomething()",
                "",
                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
                "Those methods *cannot* be stubbed/verified.",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="98" endline="109">
return new MissingMethodInvocationException(join(
                "when() requires an argument which has to be 'a method call on a mock'.",
                "For example:",
                "    when(mock.getArticles()).thenReturn(articles);",
                "",
                "Also, this error might show up because:",
                "1. you stub either of: final/private/equals()/hashCode() methods.",
                "   Those methods *cannot* be stubbed/verified.",
                "   " + MockitoLimitations.NON_PUBLIC_PARENT,
                "2. inside when() you don't call method on mock but on some other object.",
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="7">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="113" endline="124">
return new UnfinishedVerificationException(join(
                "Missing method call for verify(mock) here:",
                location,
                "",
                "Example of correct verification:",
                "    verify(mock).doSomething()",
                "",
                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
                "Those methods *cannot* be stubbed/verified.",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="12">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="113" endline="124">
return new UnfinishedVerificationException(join(
                "Missing method call for verify(mock) here:",
                location,
                "",
                "Example of correct verification:",
                "    verify(mock).doSomething()",
                "",
                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
                "Those methods *cannot* be stubbed/verified.",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="14">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="113" endline="124">
return new UnfinishedVerificationException(join(
                "Missing method call for verify(mock) here:",
                location,
                "",
                "Example of correct verification:",
                "    verify(mock).doSomething()",
                "",
                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
                "Those methods *cannot* be stubbed/verified.",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
    </clone>
    <clone nlines="10" distance="17">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="113" endline="124">
return new UnfinishedVerificationException(join(
                "Missing method call for verify(mock) here:",
                location,
                "",
                "Example of correct verification:",
                "    verify(mock).doSomething()",
                "",
                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
                "Those methods *cannot* be stubbed/verified.",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="342" endline="351">
return new VerificationInOrderFailure(join(
                "Verification in order failure",
                "Wanted but not invoked:",
                wanted.toString(),
                new LocationImpl(),
                "Wanted anywhere AFTER following interaction:",
                previous.toString(),
                previous.getLocation(),
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="9">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="113" endline="124">
return new UnfinishedVerificationException(join(
                "Missing method call for verify(mock) here:",
                location,
                "",
                "Example of correct verification:",
                "    verify(mock).doSomething()",
                "",
                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
                "Those methods *cannot* be stubbed/verified.",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="11">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="113" endline="124">
return new UnfinishedVerificationException(join(
                "Missing method call for verify(mock) here:",
                location,
                "",
                "Example of correct verification:",
                "    verify(mock).doSomething()",
                "",
                "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.",
                "Those methods *cannot* be stubbed/verified.",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="6">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="98" endline="109">
return new MissingMethodInvocationException(join(
                "when() requires an argument which has to be 'a method call on a mock'.",
                "For example:",
                "    when(mock.getArticles()).thenReturn(articles);",
                "",
                "Also, this error might show up because:",
                "1. you stub either of: final/private/equals()/hashCode() methods.",
                "   Those methods *cannot* be stubbed/verified.",
                "   " + MockitoLimitations.NON_PUBLIC_PARENT,
                "2. inside when() you don't call method on mock but on some other object.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="13">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="98" endline="109">
return new MissingMethodInvocationException(join(
                "when() requires an argument which has to be 'a method call on a mock'.",
                "For example:",
                "    when(mock.getArticles()).thenReturn(articles);",
                "",
                "Also, this error might show up because:",
                "1. you stub either of: final/private/equals()/hashCode() methods.",
                "   Those methods *cannot* be stubbed/verified.",
                "   " + MockitoLimitations.NON_PUBLIC_PARENT,
                "2. inside when() you don't call method on mock but on some other object.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="16">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="98" endline="109">
return new MissingMethodInvocationException(join(
                "when() requires an argument which has to be 'a method call on a mock'.",
                "For example:",
                "    when(mock.getArticles()).thenReturn(articles);",
                "",
                "Also, this error might show up because:",
                "1. you stub either of: final/private/equals()/hashCode() methods.",
                "   Those methods *cannot* be stubbed/verified.",
                "   " + MockitoLimitations.NON_PUBLIC_PARENT,
                "2. inside when() you don't call method on mock but on some other object.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
    </clone>
    <clone nlines="10" distance="17">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="98" endline="109">
return new MissingMethodInvocationException(join(
                "when() requires an argument which has to be 'a method call on a mock'.",
                "For example:",
                "    when(mock.getArticles()).thenReturn(articles);",
                "",
                "Also, this error might show up because:",
                "1. you stub either of: final/private/equals()/hashCode() methods.",
                "   Those methods *cannot* be stubbed/verified.",
                "   " + MockitoLimitations.NON_PUBLIC_PARENT,
                "2. inside when() you don't call method on mock but on some other object.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="342" endline="351">
return new VerificationInOrderFailure(join(
                "Verification in order failure",
                "Wanted but not invoked:",
                wanted.toString(),
                new LocationImpl(),
                "Wanted anywhere AFTER following interaction:",
                previous.toString(),
                previous.getLocation(),
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="12">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="98" endline="109">
return new MissingMethodInvocationException(join(
                "when() requires an argument which has to be 'a method call on a mock'.",
                "For example:",
                "    when(mock.getArticles()).thenReturn(articles);",
                "",
                "Also, this error might show up because:",
                "1. you stub either of: final/private/equals()/hashCode() methods.",
                "   Those methods *cannot* be stubbed/verified.",
                "   " + MockitoLimitations.NON_PUBLIC_PARENT,
                "2. inside when() you don't call method on mock but on some other object.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="12">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="98" endline="109">
return new MissingMethodInvocationException(join(
                "when() requires an argument which has to be 'a method call on a mock'.",
                "For example:",
                "    when(mock.getArticles()).thenReturn(articles);",
                "",
                "Also, this error might show up because:",
                "1. you stub either of: final/private/equals()/hashCode() methods.",
                "   Those methods *cannot* be stubbed/verified.",
                "   " + MockitoLimitations.NON_PUBLIC_PARENT,
                "2. inside when() you don't call method on mock but on some other object.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="8">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="11">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
    </clone>
    <clone nlines="10" distance="20">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="342" endline="351">
return new VerificationInOrderFailure(join(
                "Verification in order failure",
                "Wanted but not invoked:",
                wanted.toString(),
                new LocationImpl(),
                "Wanted anywhere AFTER following interaction:",
                previous.toString(),
                previous.getLocation(),
                ""
        ));
</source>
    </clone>
    <clone nlines="15" distance="6">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="14" distance="7">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="15" distance="15">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="67" endline="81">
return new UnfinishedStubbingException(join(
                "Unfinished stubbing detected here:",
                location,
                "",
                "E.g. thenReturn() may be missing.",
                "Examples of correct stubbing:",
                "    when(mock.isOk()).thenReturn(true);",
                "    when(mock.isOk()).thenThrow(exception);",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "Hints:",
                " 1. missing thenReturn()",
                " 2. you are trying to stub a final method, which is not supported",
                " 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="233" endline="248">
return new InvalidUseOfMatchersException(join(
                "Invalid use of argument matchers!",
                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() + " recorded:" +
                        locationsOf(recordedMatchers),
                "",
                "This exception may occur if matchers are combined with raw values:",
                "    //incorrect:",
                "    someMethod(anyObject(), \"raw String\");",
                "When using matchers, all arguments have to be provided by matchers.",
                "For example:",
                "    //correct:",
                "    someMethod(anyObject(), eq(\"String by matcher\"));",
                "",
                "For more info see javadoc for Matchers class.",
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="17">
        <source file="java/org/mockito/internal/util/Platform.java" startline="22" endline="37">
return String.format("Java               : %s\n" +
                             "JVM vendor name    : %s\n" +
                             "JVM vendor version : %s\n" +
                             "JVM name           : %s\n" +
                             "JVM version        : %s\n" +
                             "JVM info           : %s\n" +
                             "OS name            : %s\n" +
                             "OS version         : %s\n",
                             JAVA_VERSION,
                             JVM_VENDOR,
                             JVM_VENDOR_VERSION,
                             JVM_NAME,
                             JVM_VERSION,
                             JVM_INFO,
                             OS_NAME,
                             OS_VERSION);
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="19">
        <source file="java/org/mockito/internal/util/Platform.java" startline="22" endline="37">
return String.format("Java               : %s\n" +
                             "JVM vendor name    : %s\n" +
                             "JVM vendor version : %s\n" +
                             "JVM name           : %s\n" +
                             "JVM version        : %s\n" +
                             "JVM info           : %s\n" +
                             "OS name            : %s\n" +
                             "OS version         : %s\n",
                             JAVA_VERSION,
                             JVM_VENDOR,
                             JVM_VENDOR_VERSION,
                             JVM_NAME,
                             JVM_VERSION,
                             JVM_INFO,
                             OS_NAME,
                             OS_VERSION);
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
    </clone>
    <clone nlines="15" distance="20">
        <source file="java/org/mockito/internal/util/Platform.java" startline="22" endline="37">
return String.format("Java               : %s\n" +
                             "JVM vendor name    : %s\n" +
                             "JVM vendor version : %s\n" +
                             "JVM name           : %s\n" +
                             "JVM version        : %s\n" +
                             "JVM info           : %s\n" +
                             "OS name            : %s\n" +
                             "OS version         : %s\n",
                             JAVA_VERSION,
                             JVM_VENDOR,
                             JVM_VENDOR_VERSION,
                             JVM_NAME,
                             JVM_VERSION,
                             JVM_INFO,
                             OS_NAME,
                             OS_VERSION);
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="14" distance="17">
        <source file="java/org/mockito/internal/util/Platform.java" startline="22" endline="37">
return String.format("Java               : %s\n" +
                             "JVM vendor name    : %s\n" +
                             "JVM vendor version : %s\n" +
                             "JVM name           : %s\n" +
                             "JVM version        : %s\n" +
                             "JVM info           : %s\n" +
                             "OS name            : %s\n" +
                             "OS version         : %s\n",
                             JAVA_VERSION,
                             JVM_VENDOR,
                             JVM_VENDOR_VERSION,
                             JVM_NAME,
                             JVM_VERSION,
                             JVM_INFO,
                             OS_NAME,
                             OS_VERSION);
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="13">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
    </clone>
    <clone nlines="12" distance="13">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="10">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="12" distance="15">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="477" endline="488">
return new WrongTypeOfReturnValue(join(
                actualType + " cannot be returned by " + methodName + "()",
                methodName + "() should return " + expectedType,
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. This exception *might* occur in wrongly written multi-threaded tests.",
                "   Please refer to Mockito FAQ on limitations of concurrency testing.",
                "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="233" endline="248">
return new InvalidUseOfMatchersException(join(
                "Invalid use of argument matchers!",
                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() + " recorded:" +
                        locationsOf(recordedMatchers),
                "",
                "This exception may occur if matchers are combined with raw values:",
                "    //incorrect:",
                "    someMethod(anyObject(), \"raw String\");",
                "When using matchers, all arguments have to be provided by matchers.",
                "For example:",
                "    //correct:",
                "    someMethod(anyObject(), eq(\"String by matcher\"));",
                "",
                "For more info see javadoc for Matchers class.",
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="16">
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="233" endline="248">
return new InvalidUseOfMatchersException(join(
                "Invalid use of argument matchers!",
                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() + " recorded:" +
                        locationsOf(recordedMatchers),
                "",
                "This exception may occur if matchers are combined with raw values:",
                "    //incorrect:",
                "    someMethod(anyObject(), \"raw String\");",
                "When using matchers, all arguments have to be provided by matchers.",
                "For example:",
                "    //correct:",
                "    someMethod(anyObject(), eq(\"String by matcher\"));",
                "",
                "For more info see javadoc for Matchers class.",
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="13">
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java" startline="96" endline="106">
throw new MockitoException(join(
                "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                "",
                "Mockito can only non-private &amp; non-final classes.",
                "If you're not sure why you're getting this error, please report to the mailing list.",
                "",
                Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : "",
                Platform.describe(),
                "",
                "Underlying exception : " + generationFailed
        ), generationFailed);
</source>
    </clone>
    <clone nlines="11" distance="16">
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="204" endline="216">
throw new MockitoException(join(
                "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                "",
                "If you're not sure why you're getting this error, please report to the mailing list.",
                "",
                Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : "",
                Platform.describe(),
                "",
                "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                "",
                "Underlying exception : " + generationFailed
        ), generationFailed);
</source>
    </clone>
    <clone nlines="11" distance="19">
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="182" endline="192">
throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="181" endline="193">
if (Modifier.isFinal(mockFeatures.getTypeToMock().getModifiers())) {
            throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
        }
</source>
    </clone>
    <clone nlines="10" distance="19">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="342" endline="351">
return new VerificationInOrderFailure(join(
                "Verification in order failure",
                "Wanted but not invoked:",
                wanted.toString(),
                new LocationImpl(),
                "Wanted anywhere AFTER following interaction:",
                previous.toString(),
                previous.getLocation(),
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="11" distance="20">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java" startline="96" endline="106">
throw new MockitoException(join(
                "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                "",
                "Mockito can only non-private &amp; non-final classes.",
                "If you're not sure why you're getting this error, please report to the mailing list.",
                "",
                Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : "",
                Platform.describe(),
                "",
                "Underlying exception : " + generationFailed
        ), generationFailed);
</source>
    </clone>
    <clone nlines="14" distance="6">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
    </clone>
    <clone nlines="15" distance="15">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="508" endline="522">
return new InvalidUseOfMatchersException(join(
                "Misplaced argument matcher detected here:",
                locationsOf(lastMatchers),
                "",
                "You cannot use argument matchers outside of verification or stubbing.",
                "Examples of correct usage of argument matchers:",
                "    when(mock.get(anyInt())).thenReturn(null);",
                "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());",
                "    verify(mock).someMethod(contains(\"foo\"))",
                "",
                "Also, this error might show up because you use argument matchers with methods that cannot be mocked.",
                "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().",
                MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="233" endline="248">
return new InvalidUseOfMatchersException(join(
                "Invalid use of argument matchers!",
                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() + " recorded:" +
                        locationsOf(recordedMatchers),
                "",
                "This exception may occur if matchers are combined with raw values:",
                "    //incorrect:",
                "    someMethod(anyObject(), \"raw String\");",
                "When using matchers, all arguments have to be provided by matchers.",
                "For example:",
                "    //correct:",
                "    someMethod(anyObject(), eq(\"String by matcher\"));",
                "",
                "For more info see javadoc for Matchers class.",
                ""
        ));
</source>
    </clone>
    <clone nlines="14" distance="17">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="448" endline="461">
return new CannotStubVoidMethodWithReturnValue(join(
                "'" + methodName + "' is a *void method* and it *cannot* be stubbed with a *return value*!",
                "Voids are usually stubbed with Throwables:",
                "    doThrow(exception).when(mock).someVoidMethod();",
                "***",
                "If you're unsure why you're getting above error read on.",
                "Due to the nature of the syntax above problem might occur because:",
                "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.",
                "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.",
                "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
                "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
                "4. " + MockitoLimitations.NON_PUBLIC_PARENT,
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="233" endline="248">
return new InvalidUseOfMatchersException(join(
                "Invalid use of argument matchers!",
                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() + " recorded:" +
                        locationsOf(recordedMatchers),
                "",
                "This exception may occur if matchers are combined with raw values:",
                "    //incorrect:",
                "    someMethod(anyObject(), \"raw String\");",
                "When using matchers, all arguments have to be provided by matchers.",
                "For example:",
                "    //correct:",
                "    someMethod(anyObject(), eq(\"String by matcher\"));",
                "",
                "For more info see javadoc for Matchers class.",
                ""
        ));
</source>
    </clone>
    <clone nlines="10" distance="20">
        <source file="java/org/mockito/internal/configuration/plugins/PluginLoader.java" startline="41" endline="50">
try {
            // Default implementation. Use our own ClassLoader instead of the context
            // ClassLoader, as the default implementation is assumed to be part of
            // Mockito and may not be available via the context ClassLoader.
            return pluginType.cast(Class.forName(defaultPluginClassName).newInstance());
        } catch (Exception e) {
            throw new IllegalStateException("Internal problem occurred, please report it. " +
                    "Mockito is unable to load the default implementation of class that is a part of Mockito distribution. " +
                    "Failed to load " + pluginType, e);
        }
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/ByteBuddyCrossClassLoaderSerializationSupport.java" startline="308" endline="318">
try {
                Field classNameField = descInstance.getClass().getDeclaredField("name");
                setField(descInstance, classNameField,proxyClass.getCanonicalName());
            } catch (NoSuchFieldException nsfe) {
                throw new MockitoSerializationIssue(join(
                        "Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',",
                        "this is definitely a bug in our code as it means the JDK team changed a few internal things.",
                        "",
                        "Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome."
                ), nsfe);
            }
</source>
    </clone>
    <clone nlines="16" distance="12">
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="233" endline="248">
return new InvalidUseOfMatchersException(join(
                "Invalid use of argument matchers!",
                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() + " recorded:" +
                        locationsOf(recordedMatchers),
                "",
                "This exception may occur if matchers are combined with raw values:",
                "    //incorrect:",
                "    someMethod(anyObject(), \"raw String\");",
                "When using matchers, all arguments have to be provided by matchers.",
                "For example:",
                "    //correct:",
                "    someMethod(anyObject(), eq(\"String by matcher\"));",
                "",
                "For more info see javadoc for Matchers class.",
                ""
        ));
</source>
        <source file="java/org/mockito/internal/exceptions/Reporter.java" startline="252" endline="269">
return new InvalidUseOfMatchersException(join(
                "Invalid use of argument matchers inside additional matcher " + additionalMatcherName + " !",
                new LocationImpl(),
                "",
                expectedSubMatchersCount + " sub matchers expected, " + matcherStack.size() + " recorded:",
                locationsOf(matcherStack),
                "",
                "This exception may occur if matchers are combined with raw values:",
                "    //incorrect:",
                "    someMethod(AdditionalMatchers.and(isNotNull(), \"raw String\");",
                "When using matchers, all arguments have to be provided by matchers.",
                "For example:",
                "    //correct:",
                "    someMethod(AdditionalMatchers.and(isNotNull(), eq(\"raw String\"));",
                "",
                "For more info see javadoc for Matchers and AdditionalMatchers classes.",
                ""
        ));
</source>
    </clone>
    <clone nlines="10" distance="8">
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="194" endline="203">
if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
            throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Most likely it is a private class that is not visible by Mockito",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    ""
            ), generationFailed);
        }
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="181" endline="193">
if (Modifier.isFinal(mockFeatures.getTypeToMock().getModifiers())) {
            throw new MockitoException(join(
                    "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                    "Can not mock final classes with the following settings :",
                    " - explicit serialization (e.g. withSettings().serializable())",
                    " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
                    "",
                    "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                    "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                    "",
                    "Underlying exception : " + generationFailed
            ), generationFailed);
        }
</source>
    </clone>
    <clone nlines="11" distance="8">
        <source file="java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java" startline="96" endline="106">
throw new MockitoException(join(
                "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                "",
                "Mockito can only non-private &amp; non-final classes.",
                "If you're not sure why you're getting this error, please report to the mailing list.",
                "",
                Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : "",
                Platform.describe(),
                "",
                "Underlying exception : " + generationFailed
        ), generationFailed);
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="204" endline="216">
throw new MockitoException(join(
                "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
                "",
                "If you're not sure why you're getting this error, please report to the mailing list.",
                "",
                Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : "",
                Platform.describe(),
                "",
                "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
                "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
                "",
                "Underlying exception : " + generationFailed
        ), generationFailed);
</source>
    </clone>
    <clone nlines="14" distance="10">
        <source file="java/org/mockito/internal/verification/VerificationOverTimeImpl.java" startline="77" endline="90">
try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (AssertionError e) {
                error = handleVerifyException(e);
            }
</source>
        <source file="java/org/mockito/internal/verification/VerificationOverTimeImpl.java" startline="76" endline="91">
while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (AssertionError e) {
                error = handleVerifyException(e);
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="2">
        <source file="java/org/mockito/internal/util/JavaEightUtil.java" startline="52" endline="61">
try {
            final Class&lt;?&gt; optionalClass = Class.forName("java.util.stream.Stream");
            final Method emptyMethod = optionalClass.getMethod("empty");

            return emptyMethod.invoke(null);
            // any exception is really unexpected since the type name has
            // already been verified
        } catch (Exception e) {
            throw new InstantiationException("Could not create java.util.stream.Stream#empty(): " + e, e);
        }
</source>
        <source file="java/org/mockito/internal/util/JavaEightUtil.java" startline="32" endline="41">
try {
            final Class&lt;?&gt; optionalClass = Class.forName("java.util.Optional");
            final Method emptyMethod = optionalClass.getMethod("empty");

            return emptyOptional = emptyMethod.invoke(null);
            // any exception is really unexpected since the type name has
            // already been verified to be java.util.Optional
        } catch (Exception e) {
            throw new InstantiationException("Could not create java.util.Optional#empty(): " + e, e);
        }
</source>
    </clone>
    <clone nlines="12" distance="17">
        <source file="java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java" startline="46" endline="57">
RunListener listener = new RunListener() {
            WarningsCollector warningsCollector;
            
            @Override
            public void testStarted(Description description) throws Exception {
                warningsCollector = new WarningsCollector();
            }
            
            @Override public void testFailure(Failure failure) throws Exception {                
                logger.log(warningsCollector.getWarnings());
            }
        };
</source>
        <source file="java/org/mockito/runners/VerboseMockitoJUnitRunner.java" startline="45" endline="60">
RunListener listener = new RunListener() {
            
            WarningsCollector warningsCollector;
                       
            @Override
            public void testStarted(Description description) throws Exception {
                warningsCollector = new WarningsCollector();
            }
            
            @Override
            @SuppressWarnings("deprecation")
            public void testFailure(final Failure failure) throws Exception {       
                String warnings = warningsCollector.getWarnings();
                new JUnitFailureHacker().appendWarnings(failure, warnings);                              
            }
        };
</source>
    </clone>
    <clone nlines="10" distance="9">
        <source file="java/org/mockito/internal/MockitoCore.java" startline="119" endline="128">
try {
                if (mock == null) {
                    throw nullPassedToVerifyNoMoreInteractions();
                }
                InvocationContainer invocations = getMockHandler(mock).getInvocationContainer();
                VerificationDataImpl data = new VerificationDataImpl(invocations, null);
                noMoreInteractions().verify(data);
            } catch (NotAMockException e) {
                throw notAMockPassedToVerifyNoMoreInteractions();
            }
</source>
        <source file="java/org/mockito/internal/MockitoCore.java" startline="118" endline="129">
for (Object mock : mocks) {
            try {
                if (mock == null) {
                    throw nullPassedToVerifyNoMoreInteractions();
                }
                InvocationContainer invocations = getMockHandler(mock).getInvocationContainer();
                VerificationDataImpl data = new VerificationDataImpl(invocations, null);
                noMoreInteractions().verify(data);
            } catch (NotAMockException e) {
                throw notAMockPassedToVerifyNoMoreInteractions();
            }
        }
</source>
    </clone>
    <clone nlines="10" distance="11">
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="128" endline="137">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2));
                return null;
            }
        };
</source>
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="151" endline="160">
return new Answer&lt;T&gt;() {
            @SuppressWarnings("unchecked")
            public T answer(InvocationOnMock invocation) throws Throwable {
                return answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3));
            }
        };
</source>
    </clone>
    <clone nlines="10" distance="20">
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="128" endline="137">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2));
                return null;
            }
        };
</source>
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="222" endline="233">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3),
                        (E)invocation.getArgument(4));
                return null;
            }
        };
</source>
    </clone>
    <clone nlines="10" distance="10">
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="128" endline="137">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2));
                return null;
            }
        };
</source>
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="173" endline="183">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3));
                return null;
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="19">
        <source file="java/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java" startline="38" endline="48">
if (MockUtil.isMock(instance)) {
                    // A. instance has been spied earlier
                    // B. protect against multiple use of MockitoAnnotations.initMocks()
                    Mockito.reset(instance);
                } else {
                    Object mock = Mockito.mock(instance.getClass(), withSettings()
					    .spiedInstance(instance)
					    .defaultAnswer(Mockito.CALLS_REAL_METHODS)
					    .name(field.getName()));
					setField(fieldOwner, field, mock);
                }
</source>
        <source file="java/org/mockito/internal/configuration/SpyAnnotationEngine.java" startline="58" endline="69">
if (MockUtil.isMock(instance)) {
                        // instance has been spied earlier
                        // for example happens when MockitoAnnotations.initMocks is called two times.
                        Mockito.reset(instance);
                    } else if (instance != null) {
                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()
                                .spiedInstance(instance)
                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)
                                .name(field.getName())));
                    } else {
                        field.set(testInstance, newSpyInstance(testInstance, field));
                    }
</source>
    </clone>
    <clone nlines="10" distance="13">
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="151" endline="160">
return new Answer&lt;T&gt;() {
            @SuppressWarnings("unchecked")
            public T answer(InvocationOnMock invocation) throws Throwable {
                return answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3));
            }
        };
</source>
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="222" endline="233">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3),
                        (E)invocation.getArgument(4));
                return null;
            }
        };
</source>
    </clone>
    <clone nlines="10" distance="4">
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="151" endline="160">
return new Answer&lt;T&gt;() {
            @SuppressWarnings("unchecked")
            public T answer(InvocationOnMock invocation) throws Throwable {
                return answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3));
            }
        };
</source>
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="173" endline="183">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3));
                return null;
            }
        };
</source>
    </clone>
    <clone nlines="10" distance="10">
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="151" endline="160">
return new Answer&lt;T&gt;() {
            @SuppressWarnings("unchecked")
            public T answer(InvocationOnMock invocation) throws Throwable {
                return answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3));
            }
        };
</source>
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="198" endline="208">
return new Answer&lt;T&gt;() {
            @SuppressWarnings("unchecked")
            public T answer(InvocationOnMock invocation) throws Throwable {
                return answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3),
                        (E)invocation.getArgument(4));
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="10">
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="173" endline="183">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3));
                return null;
            }
        };
</source>
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="222" endline="233">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3),
                        (E)invocation.getArgument(4));
                return null;
            }
        };
</source>
    </clone>
    <clone nlines="11" distance="11">
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="173" endline="183">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3));
                return null;
            }
        };
</source>
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="198" endline="208">
return new Answer&lt;T&gt;() {
            @SuppressWarnings("unchecked")
            public T answer(InvocationOnMock invocation) throws Throwable {
                return answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3),
                        (E)invocation.getArgument(4));
            }
        };
</source>
    </clone>
    <clone nlines="17" distance="14">
        <source file="java/org/mockito/internal/configuration/plugins/PluginFinder.java" startline="21" endline="37">
try {
                s = resource.openStream();
                String pluginClassName = new PluginFileReader().readPluginClass(s);
                if (pluginClassName == null) {
                    //For backwards compatibility
                    //If the resource does not have plugin class name we're ignoring it
                    continue;
                }
                if (!pluginSwitch.isEnabled(pluginClassName)) {
                    continue;
                }
                return pluginClassName;
            } catch(Exception e) {
                throw new MockitoException("Problems reading plugin implementation from: " + resource, e);
            } finally {
                IOUtil.closeQuietly(s);
            }
</source>
        <source file="java/org/mockito/internal/configuration/plugins/PluginFinder.java" startline="19" endline="38">
for (URL resource : resources) {
            InputStream s = null;
            try {
                s = resource.openStream();
                String pluginClassName = new PluginFileReader().readPluginClass(s);
                if (pluginClassName == null) {
                    //For backwards compatibility
                    //If the resource does not have plugin class name we're ignoring it
                    continue;
                }
                if (!pluginSwitch.isEnabled(pluginClassName)) {
                    continue;
                }
                return pluginClassName;
            } catch(Exception e) {
                throw new MockitoException("Problems reading plugin implementation from: " + resource, e);
            } finally {
                IOUtil.closeQuietly(s);
            }
        }
</source>
    </clone>
    <clone nlines="13" distance="14">
        <source file="java/org/mockito/internal/configuration/DefaultAnnotationEngine.java" startline="62" endline="74">
for(Annotation annotation : field.getAnnotations()) {           
                Object mock = createMockFor(annotation, field);
                if (mock != null) {
                    throwIfAlreadyAssigned(field, alreadyAssigned);                    
                    alreadyAssigned = true;                    
                    try {
                        setField(testInstance, field,mock);
                    } catch (Exception e) {
                        throw new MockitoException("Problems setting field " + field.getName() + " annotated with "
                                + annotation, e);
                    }
                }        
            }
</source>
        <source file="java/org/mockito/internal/configuration/DefaultAnnotationEngine.java" startline="60" endline="75">
for (Field field : fields) {
            boolean alreadyAssigned = false;
            for(Annotation annotation : field.getAnnotations()) {           
                Object mock = createMockFor(annotation, field);
                if (mock != null) {
                    throwIfAlreadyAssigned(field, alreadyAssigned);                    
                    alreadyAssigned = true;                    
                    try {
                        setField(testInstance, field,mock);
                    } catch (Exception e) {
                        throw new MockitoException("Problems setting field " + field.getName() + " annotated with "
                                + annotation, e);
                    }
                }        
            }
        }
</source>
    </clone>
    <clone nlines="11" distance="4">
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="198" endline="208">
return new Answer&lt;T&gt;() {
            @SuppressWarnings("unchecked")
            public T answer(InvocationOnMock invocation) throws Throwable {
                return answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3),
                        (E)invocation.getArgument(4));
            }
        };
</source>
        <source file="java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java" startline="222" endline="233">
return new Answer&lt;Void&gt;() {
            @SuppressWarnings("unchecked")
            public Void answer(InvocationOnMock invocation) throws Throwable {
                answer.answer(
                        (A)invocation.getArgument(0),
                        (B)invocation.getArgument(1),
                        (C)invocation.getArgument(2),
                        (D)invocation.getArgument(3),
                        (E)invocation.getArgument(4));
                return null;
            }
        };
</source>
    </clone>
    <clone nlines="20" distance="13">
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java" startline="252" endline="271">
return new TypeMockability() {
            @Override
            public boolean mockable() {
                return instrumentation.isModifiableClass(type) &amp;&amp; !EXCLUDES.contains(type);
            }

            @Override
            public String nonMockableReason() {
                if (mockable()) {
                    return "";
                }
                if (type.isPrimitive()) {
                    return "primitive type";
                }
                if (EXCLUDES.contains(type)) {
                    return "Cannot mock wrapper types, String.class or Class.class";
                }
                return "VM does not not support modification of given type";
            }
        };
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java" startline="134" endline="153">
return new TypeMockability() {
            @Override
            public boolean mockable() {
                return !type.isPrimitive() &amp;&amp; !Modifier.isFinal(type.getModifiers());
            }

            @Override
            public String nonMockableReason() {
                if(mockable()) {
                    return "";
                }
                if (type.isPrimitive()) {
                    return "primitive type";
                }
                if (Modifier.isFinal(type.getModifiers())) {
                    return "final class";
                }
                return join("not handled type");
            }
        };
</source>
    </clone>
    <clone nlines="16" distance="20">
        <source file="java/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java" startline="36" endline="51">
try {
                Object instance = fieldReader.read();
                if (MockUtil.isMock(instance)) {
                    // A. instance has been spied earlier
                    // B. protect against multiple use of MockitoAnnotations.initMocks()
                    Mockito.reset(instance);
                } else {
                    Object mock = Mockito.mock(instance.getClass(), withSettings()
					    .spiedInstance(instance)
					    .defaultAnswer(Mockito.CALLS_REAL_METHODS)
					    .name(field.getName()));
					setField(fieldOwner, field, mock);
                }
            } catch (Exception e) {
                throw new MockitoException("Problems initiating spied field " + field.getName(), e);
            }
</source>
        <source file="java/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java" startline="35" endline="52">
if(!fieldReader.isNull() &amp;&amp; field.isAnnotationPresent(Spy.class)) {
            try {
                Object instance = fieldReader.read();
                if (MockUtil.isMock(instance)) {
                    // A. instance has been spied earlier
                    // B. protect against multiple use of MockitoAnnotations.initMocks()
                    Mockito.reset(instance);
                } else {
                    Object mock = Mockito.mock(instance.getClass(), withSettings()
					    .spiedInstance(instance)
					    .defaultAnswer(Mockito.CALLS_REAL_METHODS)
					    .name(field.getName()));
					setField(fieldOwner, field, mock);
                }
            } catch (Exception e) {
                throw new MockitoException("Problems initiating spied field " + field.getName(), e);
            }
        }
</source>
    </clone>
    <clone nlines="11" distance="14">
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="29" endline="39">
if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="27" endline="39">
if (value instanceof Double) {
            return value + "d";
        } else if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
    </clone>
    <clone nlines="13" distance="14">
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="27" endline="39">
if (value instanceof Double) {
            return value + "d";
        } else if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="25" endline="39">
if (value instanceof Long) {
            return value + "L";
        } else if (value instanceof Double) {
            return value + "d";
        } else if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
    </clone>
    <clone nlines="15" distance="18">
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="25" endline="39">
if (value instanceof Long) {
            return value + "L";
        } else if (value instanceof Double) {
            return value + "d";
        } else if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="23" endline="39">
if (value instanceof Character) {
            return printChar((Character) value);
        } else if (value instanceof Long) {
            return value + "L";
        } else if (value instanceof Double) {
            return value + "d";
        } else if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
    </clone>
    <clone nlines="15" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="96" endline="110">
if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="94" endline="110">
if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
    <clone nlines="17" distance="16">
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="23" endline="39">
if (value instanceof Character) {
            return printChar((Character) value);
        } else if (value instanceof Long) {
            return value + "L";
        } else if (value instanceof Double) {
            return value + "d";
        } else if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="21" endline="39">
if (value instanceof String) {
            return "\"" + value + "\"";
        } else if (value instanceof Character) {
            return printChar((Character) value);
        } else if (value instanceof Long) {
            return value + "L";
        } else if (value instanceof Double) {
            return value + "d";
        } else if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
    </clone>
    <clone nlines="17" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="94" endline="110">
if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="92" endline="110">
if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
    <clone nlines="19" distance="12">
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="21" endline="39">
if (value instanceof String) {
            return "\"" + value + "\"";
        } else if (value instanceof Character) {
            return printChar((Character) value);
        } else if (value instanceof Long) {
            return value + "L";
        } else if (value instanceof Double) {
            return value + "d";
        } else if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
        <source file="java/org/mockito/internal/matchers/text/ValuePrinter.java" startline="19" endline="39">
if (value == null) {
            return "null";
        } else if (value instanceof String) {
            return "\"" + value + "\"";
        } else if (value instanceof Character) {
            return printChar((Character) value);
        } else if (value instanceof Long) {
            return value + "L";
        } else if (value instanceof Double) {
            return value + "d";
        } else if (value instanceof Float) {
            return value + "f";
        } else if (value instanceof Byte) {
            return String.format("0x%02X", (Byte) value);
        } else if (value instanceof Map) {
            return printMap((Map) value);
        } else if (value.getClass().isArray()) {
            return printValues("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            return (((FormattedText) value).getText());
        }
</source>
    </clone>
    <clone nlines="23" distance="9">
        <source file="java/org/mockito/internal/configuration/SpyAnnotationEngine.java" startline="51" endline="73">
if (field.isAnnotationPresent(Spy.class) &amp;&amp; !field.isAnnotationPresent(InjectMocks.class)) {
                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, Captor.class);
                field.setAccessible(true);
                Object instance;
                try {
                    instance = field.get(testInstance);
                    assertNotInterface(instance, field.getType());
                    if (MockUtil.isMock(instance)) {
                        // instance has been spied earlier
                        // for example happens when MockitoAnnotations.initMocks is called two times.
                        Mockito.reset(instance);
                    } else if (instance != null) {
                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()
                                .spiedInstance(instance)
                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)
                                .name(field.getName())));
                    } else {
                        field.set(testInstance, newSpyInstance(testInstance, field));
                    }
                } catch (Exception e) {
                    throw new MockitoException("Unable to initialize @Spy annotated field '" + field.getName() + "'.\n" + e.getMessage(), e);
                }
            }
</source>
        <source file="java/org/mockito/internal/configuration/SpyAnnotationEngine.java" startline="50" endline="74">
for (Field field : fields) {
            if (field.isAnnotationPresent(Spy.class) &amp;&amp; !field.isAnnotationPresent(InjectMocks.class)) {
                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, Captor.class);
                field.setAccessible(true);
                Object instance;
                try {
                    instance = field.get(testInstance);
                    assertNotInterface(instance, field.getType());
                    if (MockUtil.isMock(instance)) {
                        // instance has been spied earlier
                        // for example happens when MockitoAnnotations.initMocks is called two times.
                        Mockito.reset(instance);
                    } else if (instance != null) {
                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()
                                .spiedInstance(instance)
                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)
                                .name(field.getName())));
                    } else {
                        field.set(testInstance, newSpyInstance(testInstance, field));
                    }
                } catch (Exception e) {
                    throw new MockitoException("Unable to initialize @Spy annotated field '" + field.getName() + "'.\n" + e.getMessage(), e);
                }
            }
        }
</source>
    </clone>
    <clone nlines="14" distance="13">
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java" startline="138" endline="151">
return byteBuddy.redefine(classBeingRedefined, ClassFileLocator.Simple.of(classBeingRedefined.getName(), classfileBuffer))
                        .visit(Advice.withCustomMapping()
                                .bind(MockMethodAdvice.Identifier.class, identifier)
                                .to(MockMethodAdvice.class).on(isVirtual()
                                        .and(not(isBridge().or(isHashCode()).or(isEquals()).or(isDefaultFinalizer())))
                                        .and(not(isDeclaredBy(nameStartsWith("java.")).&lt;MethodDescription&gt;and(isPackagePrivate())))))
                        .visit(Advice.withCustomMapping()
                                .bind(MockMethodAdvice.Identifier.class, identifier)
                                .to(MockMethodAdvice.ForHashCode.class).on(isHashCode()))
                        .visit(Advice.withCustomMapping()
                                .bind(MockMethodAdvice.Identifier.class, identifier)
                                .to(MockMethodAdvice.ForEquals.class).on(isEquals()))
                        .make()
                        .getBytes();
</source>
        <source file="java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java" startline="137" endline="154">
try {
                return byteBuddy.redefine(classBeingRedefined, ClassFileLocator.Simple.of(classBeingRedefined.getName(), classfileBuffer))
                        .visit(Advice.withCustomMapping()
                                .bind(MockMethodAdvice.Identifier.class, identifier)
                                .to(MockMethodAdvice.class).on(isVirtual()
                                        .and(not(isBridge().or(isHashCode()).or(isEquals()).or(isDefaultFinalizer())))
                                        .and(not(isDeclaredBy(nameStartsWith("java.")).&lt;MethodDescription&gt;and(isPackagePrivate())))))
                        .visit(Advice.withCustomMapping()
                                .bind(MockMethodAdvice.Identifier.class, identifier)
                                .to(MockMethodAdvice.ForHashCode.class).on(isHashCode()))
                        .visit(Advice.withCustomMapping()
                                .bind(MockMethodAdvice.Identifier.class, identifier)
                                .to(MockMethodAdvice.ForEquals.class).on(isEquals()))
                        .make()
                        .getBytes();
            } catch (Throwable throwable) {
                return null;
            }
</source>
    </clone>
    <clone nlines="19" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="92" endline="110">
if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="90" endline="110">
if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
    <clone nlines="22" distance="19">
        <source file="java/org/mockito/internal/util/reflection/FieldInitializer.java" startline="190" endline="211">
try {
                constructor = field.getType().getDeclaredConstructor();
                changer.enableAccess(constructor);

                final Object[] noArg = new Object[0];
                Object newFieldInstance = constructor.newInstance(noArg);
                setField(testClass, field,newFieldInstance);

                return new FieldInitializationReport(field.get(testClass), true, false);
            } catch (NoSuchMethodException e) {
                throw new MockitoException("the type '" + field.getType().getSimpleName() + "' has no default constructor", e);
            } catch (InvocationTargetException e) {
                throw new MockitoException("the default constructor of type '" + field.getType().getSimpleName() + "' has raised an exception (see the stack trace for cause): " + e.getTargetException().toString(), e);
            } catch (InstantiationException e) {
                throw new MockitoException("InstantiationException (see the stack trace for cause): " + e.toString(), e);
            } catch (IllegalAccessException e) {
                throw new MockitoException("IllegalAccessException (see the stack trace for cause): " + e.toString(), e);
            } finally {
                if(constructor != null) {
                    changer.safelyDisableAccess(constructor);
                }
            }
</source>
        <source file="java/org/mockito/internal/util/reflection/FieldInitializer.java" startline="264" endline="285">
try {
                constructor = biggestConstructor(field.getType());
                changer.enableAccess(constructor);

                final Object[] args = argResolver.resolveTypeInstances(constructor.getParameterTypes());
                Object newFieldInstance = constructor.newInstance(args);
                setField(testClass, field,newFieldInstance);

                return new FieldInitializationReport(field.get(testClass), false, true);
            } catch (IllegalArgumentException e) {
                throw new MockitoException("internal error : argResolver provided incorrect types for constructor " + constructor + " of type " + field.getType().getSimpleName(), e);
            } catch (InvocationTargetException e) {
                throw new MockitoException("the constructor of type '" + field.getType().getSimpleName() + "' has raised an exception (see the stack trace for cause): " + e.getTargetException().toString(), e);
            } catch (InstantiationException e) {
                throw new MockitoException("InstantiationException (see the stack trace for cause): " + e.toString(), e);
            } catch (IllegalAccessException e) {
                throw new MockitoException("IllegalAccessException (see the stack trace for cause): " + e.toString(), e);
            } finally {
                if(constructor != null) {
                    changer.safelyDisableAccess(constructor);
                }
            }
</source>
    </clone>
    <clone nlines="21" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="90" endline="110">
if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="88" endline="110">
if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
    <clone nlines="23" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="88" endline="110">
if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="86" endline="110">
if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
    <clone nlines="25" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="84" endline="110">
if (type == SortedSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="86" endline="110">
if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
    <clone nlines="27" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="84" endline="110">
if (type == SortedSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="82" endline="110">
if (type == HashSet.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == SortedSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
    <clone nlines="29" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="82" endline="110">
if (type == HashSet.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == SortedSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="80" endline="110">
if (type == Set.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == HashSet.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == SortedSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
    <clone nlines="31" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="80" endline="110">
if (type == Set.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == HashSet.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == SortedSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="78" endline="110">
if (type == Collection.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == Set.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == HashSet.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == SortedSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
    <clone nlines="35" distance="20">
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="76" endline="110">
if (type == Iterable.class) {
            return new ArrayList&lt;Object&gt;(0);
        } else if (type == Collection.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == Set.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == HashSet.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == SortedSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
        <source file="java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java" startline="72" endline="110">
if (Primitives.isPrimitiveOrWrapper(type)) {
            return Primitives.defaultValue(type);
            //new instances are used instead of Collections.emptyList(), etc.
            //to avoid UnsupportedOperationException if code under test modifies returned collection
        } else if (type == Iterable.class) {
            return new ArrayList&lt;Object&gt;(0);
        } else if (type == Collection.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == Set.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == HashSet.class) {
            return new HashSet&lt;Object&gt;();
        } else if (type == SortedSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == TreeSet.class) {
            return new TreeSet&lt;Object&gt;();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet&lt;Object&gt;();
        } else if (type == List.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == LinkedList.class) {
            return new LinkedList&lt;Object&gt;();
        } else if (type == ArrayList.class) {
            return new ArrayList&lt;Object&gt;();
        } else if (type == Map.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == HashMap.class) {
            return new HashMap&lt;Object, Object&gt;();
        } else if (type == SortedMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == TreeMap.class) {
            return new TreeMap&lt;Object, Object&gt;();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap&lt;Object, Object&gt;();
        } else if ("java.util.Optional".equals(type.getName())) {
            return JavaEightUtil.emptyOptional();
        } else if ("java.util.stream.Stream".equals(type.getName())) {
            return JavaEightUtil.emptyStream();
        }
</source>
    </clone>
</clones>
